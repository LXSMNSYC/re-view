// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Let$ReView = require("./Let.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Opaque$ReView = require("./Opaque.bs.js");
var Exceptions$ReView = require("./Exceptions.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function Engine(Reconciler) {
  var make = function (fiberTag, props) {
    return {
            constructor: {
              contents: undefined
            },
            fiberTag: fiberTag,
            workTag: {
              contents: /* None */0
            },
            parent: {
              contents: undefined
            },
            alternate: {
              contents: undefined
            },
            sibling: {
              contents: undefined
            },
            child: {
              contents: undefined
            },
            children: {
              contents: undefined
            },
            key: {
              contents: undefined
            },
            index: {
              contents: 0
            },
            indeces: {
              contents: 0
            },
            map: Opaque$ReView.$$Map.make(/* () */0),
            ref: {
              contents: undefined
            },
            props: Opaque$ReView.convert(props),
            instance: {
              contents: undefined
            },
            error: {
              contents: undefined
            },
            hooks: {
              contents: Opaque$ReView.$$Array.make(/* () */0)
            },
            dependencies: Opaque$ReView.$$Set.make(/* () */0),
            shouldUpdate: {
              contents: false
            }
          };
  };
  var detach = function (fiber) {
    Let$ReView.$$Option.let_(fiber, (function (actualFiber) {
            var child = actualFiber.child.contents;
            var sibling = actualFiber.sibling.contents;
            var alternate = actualFiber.alternate.contents;
            actualFiber.child.contents = undefined;
            actualFiber.sibling.contents = undefined;
            actualFiber.alternate.contents = undefined;
            detach(alternate);
            detach(child);
            detach(sibling);
            return ;
          }));
    return /* () */0;
  };
  var Fiber = {
    make: make,
    detach: detach
  };
  var Instance = { };
  var make$1 = function (param, param$1) {
    var value = param$1.value;
    var context = param$1.context;
    var actualValue = value !== undefined ? Caml_option.valFromOption(value) : context.defaultValue;
    return {
            constructor: undefined,
            fiberTag: /* ContextProvider */8,
            key: param.key,
            ref: param.ref,
            props: Opaque$ReView.convert({
                  context: context,
                  value: Caml_option.some(actualValue),
                  children: param$1.children
                })
          };
  };
  var Provider = {
    make: make$1
  };
  var make$2 = function (param, param$1) {
    return {
            constructor: undefined,
            fiberTag: /* ContextProvider */8,
            key: param.key,
            ref: param.ref,
            props: Opaque$ReView.convert({
                  context: param$1.context,
                  build: param$1.build
                })
          };
  };
  var Consumer = {
    make: make$2
  };
  var read = function (wip, context) {
    return Let$ReView.OptionOrError.let_(/* tuple */[
                wip.parent.contents,
                Exceptions$ReView.MissingContext
              ], (function (param) {
                  var actualProps = Opaque$ReView.$$return(param.props);
                  if (param.fiberTag === /* ContextProvider */8 && Caml_obj.caml_equal(actualProps.context, context)) {
                    return Let$ReView.OptionOrError.let_(/* tuple */[
                                param.instance.contents,
                                Exceptions$ReView.MissingContext
                              ], Opaque$ReView.$$return);
                  } else {
                    return Let$ReView.OptionOrError.let_(/* tuple */[
                                param.parent.contents,
                                Exceptions$ReView.MissingContext
                              ], (function (actualParent) {
                                  return read(actualParent, context);
                                }));
                  }
                }));
  };
  var Context = {
    Instance: Instance,
    Provider: Provider,
    Consumer: Consumer,
    read: read
  };
  var make$3 = function (param, props) {
    return {
            constructor: undefined,
            fiberTag: /* ErrorBoundary */7,
            key: param.key,
            ref: undefined,
            props: Opaque$ReView.convert(props)
          };
  };
  var ErrorBoundary = {
    make: make$3
  };
  var make$4 = function (param, props) {
    return {
            constructor: undefined,
            fiberTag: /* Fragment */3,
            key: param.key,
            ref: undefined,
            props: Opaque$ReView.convert(props)
          };
  };
  var Fragment = {
    make: make$4
  };
  var make$5 = function (param, props) {
    return {
            constructor: undefined,
            fiberTag: /* Root */2,
            key: param.key,
            ref: param.ref,
            props: Opaque$ReView.convert(props)
          };
  };
  var Root = {
    make: make$5
  };
  var make$6 = function (param, param$1) {
    var constructor = param$1.constructor;
    return {
            constructor: Caml_option.some(Opaque$ReView.convert(constructor)),
            fiberTag: /* Host */1,
            key: param.key,
            ref: param.ref,
            props: Opaque$ReView.convert({
                  constructor: constructor,
                  attributes: param$1.attributes,
                  children: param$1.children
                })
          };
  };
  var Host = {
    make: make$6
  };
  var currentRoot = {
    contents: undefined
  };
  var wipRoot = {
    contents: undefined
  };
  var nextUnitOfWork = {
    contents: undefined
  };
  var update = function (param) {
    return Let$ReView.OptionUnit.let_(currentRoot.contents, (function (current) {
                  var fiber = make(/* Root */2, current.props);
                  fiber.instance.contents = current.instance.contents;
                  fiber.alternate.contents = current.alternate.contents;
                  wipRoot.contents = fiber;
                  nextUnitOfWork.contents = fiber;
                  return /* () */0;
                }));
  };
  var render = function (element, container) {
    var props = {
      children: /* array */[element]
    };
    var fiber = make(/* Root */2, props);
    fiber.instance.contents = Caml_option.some(Opaque$ReView.convert(container));
    fiber.alternate.contents = currentRoot.contents;
    wipRoot.contents = fiber;
    nextUnitOfWork.contents = fiber;
    return /* () */0;
  };
  var Core = {
    currentRoot: currentRoot,
    wipRoot: wipRoot,
    nextUnitOfWork: nextUnitOfWork,
    update: update,
    render: render
  };
  var getHostParent = function (wip) {
    return Let$ReView.$$Option.let_(wip.parent.contents, (function (parent) {
                  if (parent.fiberTag === /* Host */1 || parent.fiberTag === /* Root */2) {
                    return parent;
                  } else {
                    return getHostParent(parent);
                  }
                }));
  };
  var getInstanceIndex = function (wip) {
    var index = wip.indeces.contents;
    wip.indeces.contents = index + 1 | 0;
    return index;
  };
  var Utils = {
    getHostParent: getHostParent,
    getInstanceIndex: getInstanceIndex
  };
  var attachFiberAlternate = function (oldFiber, newFiber) {
    detach(oldFiber.alternate.contents);
    oldFiber.alternate.contents = undefined;
    newFiber.alternate.contents = oldFiber;
    return /* () */0;
  };
  var mapFiberToParent = function (parent, newFiber, index, key) {
    newFiber.parent.contents = parent;
    newFiber.index.contents = index;
    newFiber.key.contents = key;
    if (key !== undefined) {
      return Opaque$ReView.$$Map.set(parent.map, key, newFiber);
    } else {
      return Opaque$ReView.$$Map.set(parent.map, index, newFiber);
    }
  };
  var replaceFiber = function (parent, oldFiber, element, index, key) {
    var fiber = make(element.fiberTag, element.props);
    fiber.constructor.contents = element.constructor;
    fiber.workTag.contents = /* Replace */5;
    attachFiberAlternate(oldFiber, fiber);
    mapFiberToParent(parent, fiber, index, key);
    return fiber;
  };
  var deleteFiber = function (parent, oldFiber, index, key) {
    var fiber = make(oldFiber.fiberTag, oldFiber.props);
    fiber.constructor.contents = oldFiber.constructor.contents;
    fiber.workTag.contents = /* Delete */4;
    fiber.instance.contents = oldFiber.instance.contents;
    attachFiberAlternate(oldFiber, fiber);
    mapFiberToParent(parent, fiber, index, key);
    return fiber;
  };
  var updateFiberFromElement = function (parent, oldFiber, element, index, key) {
    var fiber = make(oldFiber.fiberTag, element.props);
    fiber.workTag.contents = /* Update */3;
    fiber.constructor.contents = oldFiber.constructor.contents;
    fiber.instance.contents = oldFiber.instance.contents;
    attachFiberAlternate(oldFiber, fiber);
    mapFiberToParent(parent, fiber, index, key);
    return fiber;
  };
  var createFiberFromElement = function (parent, element, index, key) {
    var fiber = make(element.fiberTag, element.props);
    fiber.workTag.contents = /* Placement */2;
    fiber.constructor.contents = element.constructor;
    mapFiberToParent(parent, fiber, index, key);
    return fiber;
  };
  var updateFiber = function (parent, oldFiber, element, index, key) {
    if (oldFiber !== undefined) {
      var actualOldFiber = oldFiber;
      if (element !== undefined) {
        var actualElement = element;
        return actualOldFiber.workTag.contents === /* Delete */4 ? createFiberFromElement(parent, actualElement, index, key) : (
                  actualElement.fiberTag !== actualOldFiber.fiberTag || Caml_obj.caml_notequal(actualElement.constructor, actualOldFiber.constructor.contents) ? replaceFiber(parent, actualOldFiber, actualElement, index, key) : updateFiberFromElement(parent, actualOldFiber, actualElement, index, key)
                );
      } else {
        return deleteFiber(parent, actualOldFiber, index, key);
      }
    } else if (element !== undefined) {
      return createFiberFromElement(parent, element, index, key);
    } else {
      return ;
    }
  };
  var getMatchingFiber = function (current, index, key) {
    return Let$ReView.$$Option.let_(current, (function (actualCurrent) {
                  if (key !== undefined) {
                    var actualKey = key;
                    if (Opaque$ReView.$$Map.has(actualCurrent.map, actualKey)) {
                      return Opaque$ReView.$$Map.get(actualCurrent.map, actualKey);
                    } else {
                      return Opaque$ReView.$$Map.get(actualCurrent.map, index);
                    }
                  } else {
                    return Opaque$ReView.$$Map.get(actualCurrent.map, index);
                  }
                }));
  };
  var call = function (current, wip, newChildren) {
    var previousFiber = {
      contents: undefined
    };
    var linkFiber = function (newFiber, hasElement) {
      return Let$ReView.OptionUnit.let_(newFiber, (function (fiber) {
                    if (wip.child.contents === undefined) {
                      wip.child.contents = fiber;
                    } else if (hasElement) {
                      Let$ReView.OptionUnit.let_(previousFiber.contents, (function (prev) {
                              prev.sibling.contents = fiber;
                              return /* () */0;
                            }));
                    }
                    previousFiber.contents = fiber;
                    return /* () */0;
                  }));
    };
    var marked = Opaque$ReView.$$Set.make(/* () */0);
    Let$ReView.OptionUnit.let_(newChildren, (function (children) {
            return $$Array.iteri((function (index, element) {
                          var key = element !== undefined ? element.key : undefined;
                          var oldFiber = getMatchingFiber(current, index, key);
                          var newFiber = updateFiber(wip, oldFiber, element, index, key);
                          Let$ReView.OptionUnit.let_(oldFiber, (function (actualFiber) {
                                  return Opaque$ReView.$$Set.add(marked, actualFiber);
                                }));
                          return linkFiber(newFiber, element !== undefined);
                        }), children);
          }));
    Let$ReView.OptionUnit.let_(current, (function (actualCurrent) {
            var iterateFibers = function (oldFiber) {
              return Let$ReView.OptionUnit.let_(oldFiber, (function (fiber) {
                            if (!Opaque$ReView.$$Set.has(marked, fiber)) {
                              linkFiber(deleteFiber(wip, fiber, fiber.index.contents, fiber.key.contents), false);
                            }
                            return iterateFibers(fiber.sibling.contents);
                          }));
            };
            return iterateFibers(actualCurrent.child.contents);
          }));
    return wip.child.contents;
  };
  var ReconcileChildren = {
    attachFiberAlternate: attachFiberAlternate,
    mapFiberToParent: mapFiberToParent,
    replaceFiber: replaceFiber,
    deleteFiber: deleteFiber,
    updateFiberFromElement: updateFiberFromElement,
    createFiberFromElement: createFiberFromElement,
    updateFiber: updateFiber,
    getMatchingFiber: getMatchingFiber,
    call: call
  };
  var hookFiber = {
    contents: undefined
  };
  var hookCursor = {
    contents: 0
  };
  var render$1 = function (current, wip) {
    hookFiber.contents = wip;
    hookCursor.contents = 0;
    return Let$ReView.OptionUnit.let_(current, (function (actualCurrent) {
                  wip.hooks.contents = actualCurrent.hooks.contents;
                  actualCurrent.hooks.contents = Opaque$ReView.$$Array.make(/* () */0);
                  return /* () */0;
                }));
  };
  var finishRender = function (param) {
    hookFiber.contents = undefined;
    hookCursor.contents = 0;
    return /* () */0;
  };
  var getCurrentFiber = function (param) {
    return Let$ReView.OptionOrError.let_(/* tuple */[
                hookFiber.contents,
                Exceptions$ReView.OutOfContextHookCall
              ], (function (fiber) {
                  return fiber;
                }));
  };
  var make$7 = function (tag) {
    var fiber = getCurrentFiber(/* () */0);
    hookCursor.contents = hookCursor.contents + 1 | 0;
    var slot = Opaque$ReView.$$Array.get(fiber.hooks.contents, hookCursor.contents);
    if (slot !== undefined) {
      var actualSlot = slot;
      if (actualSlot.tag !== tag) {
        throw Exceptions$ReView.IncompatibleHook;
      }
      return actualSlot;
    } else {
      var newSlot_value = {
        contents: undefined
      };
      var newSlot = {
        tag: tag,
        value: newSlot_value
      };
      Opaque$ReView.$$Array.set(fiber.hooks.contents, hookCursor.contents, newSlot);
      return newSlot;
    }
  };
  var forEach = function (wip, handler) {
    return Opaque$ReView.$$Array.forEach(wip.hooks.contents, (function (slot, param) {
                  return Curry._1(handler, slot);
                }));
  };
  var clear = function (fiber) {
    fiber.hooks.contents = Opaque$ReView.$$Array.make(/* () */0);
    return /* () */0;
  };
  var HooksContext = {
    hookFiber: hookFiber,
    hookCursor: hookCursor,
    render: render$1,
    finishRender: finishRender,
    getCurrentFiber: getCurrentFiber,
    make: make$7,
    forEach: forEach,
    clear: clear
  };
  var use = function (callback, dependency) {
    var state = make$7(/* Callback */0);
    var dep = make$7(/* Dependency */3);
    var match = state.value.contents;
    if (match !== undefined && !Caml_obj.caml_notequal(dep.value.contents, Caml_option.some(Opaque$ReView.convert(dependency)))) {
      return Opaque$ReView.$$return(Caml_option.valFromOption(match));
    } else {
      state.value.contents = Caml_option.some(Opaque$ReView.convert(callback));
      dep.value.contents = Caml_option.some(Opaque$ReView.convert(dependency));
      return callback;
    }
  };
  var Callback = {
    use: use
  };
  var use$1 = function (supplier) {
    var state = make$7(/* Constant */1);
    var match = state.value.contents;
    if (match !== undefined) {
      return Opaque$ReView.$$return(Caml_option.valFromOption(match));
    } else {
      var value = Curry._1(supplier, /* () */0);
      state.value.contents = Caml_option.some(Opaque$ReView.convert(value));
      return value;
    }
  };
  var Constant = {
    use: use$1
  };
  var use$2 = function (context) {
    var wip = getCurrentFiber(/* () */0);
    var instance = read(wip, context);
    Opaque$ReView.$$Set.add(wip.dependencies, context);
    return instance.value.contents;
  };
  var Context$1 = {
    use: use$2
  };
  var use$3 = function (effect, dependency) {
    var state = make$7(/* Effect */4);
    var dep = make$7(/* Dependency */3);
    var match = dep.value.contents;
    if (match !== undefined) {
      if (Caml_obj.caml_notequal(Caml_option.valFromOption(match), dependency)) {
        return Let$ReView.OptionUnit.let_(state.value.contents, (function (opaquePrev) {
                      var match = Opaque$ReView.$$return(opaquePrev);
                      state.value.contents = Caml_option.some(Opaque$ReView.convert(/* tuple */[
                                match[0],
                                match[1],
                                /* Update */3
                              ]));
                      dep.value.contents = Caml_option.some(Opaque$ReView.convert(dependency));
                      return /* () */0;
                    }));
      } else {
        return 0;
      }
    } else {
      state.value.contents = Caml_option.some(Opaque$ReView.convert(/* tuple */[
                effect,
                {
                  contents: undefined
                },
                /* Placement */2
              ]));
      dep.value.contents = Caml_option.some(Opaque$ReView.convert(dependency));
      return /* () */0;
    }
  };
  var Effect = {
    use: use$3
  };
  var use$4 = function (param) {
    var dispatch = make$7(/* ForceUpdate */5);
    var match = dispatch.value.contents;
    if (match !== undefined) {
      return Opaque$ReView.$$return(Caml_option.valFromOption(match));
    } else {
      var callback = function (param) {
        return update(/* () */0);
      };
      dispatch.value.contents = Caml_option.some(Opaque$ReView.convert(callback));
      return callback;
    }
  };
  var ForceUpdate = {
    use: use$4
  };
  var use$5 = function (effect, dependency) {
    var state = make$7(/* LayoutEffect */6);
    var dep = make$7(/* Dependency */3);
    var match = dep.value.contents;
    if (match !== undefined) {
      if (Caml_obj.caml_notequal(Caml_option.valFromOption(match), dependency)) {
        return Let$ReView.OptionUnit.let_(state.value.contents, (function (opaquePrev) {
                      var match = Opaque$ReView.$$return(opaquePrev);
                      state.value.contents = Caml_option.some(Opaque$ReView.convert(/* tuple */[
                                match[0],
                                match[1],
                                /* Update */3
                              ]));
                      dep.value.contents = Caml_option.some(Opaque$ReView.convert(dependency));
                      return /* () */0;
                    }));
      } else {
        return 0;
      }
    } else {
      state.value.contents = Caml_option.some(Opaque$ReView.convert(/* tuple */[
                effect,
                {
                  contents: undefined
                },
                /* Placement */2
              ]));
      dep.value.contents = Caml_option.some(Opaque$ReView.convert(dependency));
      return /* () */0;
    }
  };
  var LayoutEffect = {
    use: use$5
  };
  var use$6 = function (supplier, dependency) {
    var state = make$7(/* Memo */7);
    var dep = make$7(/* Dependency */3);
    var match = state.value.contents;
    if (match !== undefined) {
      if (Caml_obj.caml_notequal(dep.value.contents, Caml_option.some(Opaque$ReView.convert(dependency)))) {
        var value = Curry._1(supplier, /* () */0);
        state.value.contents = Caml_option.some(Opaque$ReView.convert(value));
        dep.value.contents = Caml_option.some(Opaque$ReView.convert(dependency));
        return value;
      } else {
        return Opaque$ReView.$$return(Caml_option.valFromOption(match));
      }
    } else {
      var value$1 = Curry._1(supplier, /* () */0);
      state.value.contents = Caml_option.some(Opaque$ReView.convert(value$1));
      dep.value.contents = Caml_option.some(Opaque$ReView.convert(dependency));
      return value$1;
    }
  };
  var Memo = {
    use: use$6
  };
  var use$7 = function (reducer, initial) {
    var wip = getCurrentFiber(/* () */0);
    var state = make$7(/* ReducerState */11);
    var dispatch = make$7(/* ReducerDispatch */12);
    var match = state.value.contents;
    var match$1 = dispatch.value.contents;
    if (match !== undefined && match$1 !== undefined) {
      return /* tuple */[
              Opaque$ReView.$$return(Caml_option.valFromOption(match)),
              Opaque$ReView.$$return(Caml_option.valFromOption(match$1))
            ];
    }
    var initialState = Curry._1(initial, /* () */0);
    var callback = function (action) {
      return Let$ReView.OptionUnit.let_(state.value.contents, (function (opaqueValue) {
                    var actualValue = Opaque$ReView.$$return(opaqueValue);
                    var newState = Curry._2(reducer, actualValue, action);
                    if (Caml_obj.caml_notequal(newState, actualValue)) {
                      state.value.contents = Caml_option.some(Opaque$ReView.convert(newState));
                      wip.shouldUpdate.contents = true;
                      return update(/* () */0);
                    } else {
                      return 0;
                    }
                  }));
    };
    state.value.contents = Caml_option.some(Opaque$ReView.convert(initialState));
    dispatch.value.contents = Caml_option.some(Opaque$ReView.convert(callback));
    return /* tuple */[
            initialState,
            callback
          ];
  };
  var Reducer = {
    use: use$7
  };
  var HooksFunction = {
    Callback: Callback,
    Constant: Constant,
    Context: Context$1,
    Effect: Effect,
    ForceUpdate: ForceUpdate,
    LayoutEffect: LayoutEffect,
    Memo: Memo,
    Reducer: Reducer
  };
  var safelyRender = function (wip, render) {
    try {
      return Curry._1(render, /* () */0);
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      wip.error.contents = e;
      return ;
    }
  };
  var updateBasic = function (current, wip) {
    var result = safelyRender(wip, (function (param) {
            return Let$ReView.OptionOrError.let_(/* tuple */[
                        wip.constructor.contents,
                        Exceptions$ReView.MissingBasicComponentConstructor
                      ], (function (constructor) {
                          var render = Opaque$ReView.$$return(constructor);
                          var props = Opaque$ReView.$$return(wip.props);
                          return Curry._2(render, {
                                      key: wip.key.contents,
                                      ref: wip.ref.contents
                                    }, props);
                        }));
          }));
    if (result !== undefined) {
      return call(current, wip, /* array */[result]);
    }
    
  };
  var updateComponent = function (current, wip) {
    render$1(current, wip);
    var result = safelyRender(wip, (function (param) {
            return Let$ReView.OptionOrError.let_(/* tuple */[
                        wip.constructor.contents,
                        Exceptions$ReView.MissingBasicComponentConstructor
                      ], (function (constructor) {
                          var render = Opaque$ReView.$$return(constructor);
                          var props = Opaque$ReView.$$return(wip.props);
                          return Curry._2(render, props, {
                                      key: wip.key.contents,
                                      ref: wip.ref.contents
                                    });
                        }));
          }));
    finishRender(/* () */0);
    if (result !== undefined) {
      return call(current, wip, /* array */[result]);
    }
    
  };
  var updateContextConsumer = function (current, wip) {
    var props = Opaque$ReView.$$return(wip.props);
    var result = safelyRender(wip, (function (param) {
            var instance = read(wip, props.context);
            var children = instance.shouldUpdate.contents ? Curry._1(props.build, instance.value.contents) : Let$ReView.$$Option.let_(current, (function (actualCurrent) {
                      var result = actualCurrent.children.contents;
                      actualCurrent.children.contents = undefined;
                      return result;
                    }));
            wip.children.contents = children;
            return children;
          }));
    if (result !== undefined) {
      return call(current, wip, /* array */[result]);
    }
    
  };
  var updateContextProvider = function (current, wip) {
    var props = Opaque$ReView.$$return(wip.props);
    return Let$ReView.OptionOrError.let_(/* tuple */[
                props.value,
                Exceptions$ReView.DesyncContextValue
              ], (function (actualValue) {
                  var match = wip.instance.contents;
                  if (match !== undefined) {
                    var instance = Opaque$ReView.$$return(Caml_option.valFromOption(match));
                    Let$ReView.OptionOrError.let_(/* tuple */[
                          current,
                          Exceptions$ReView.UnboundContextInstance
                        ], (function (actualCurrent) {
                            return Let$ReView.OptionOrError.let_(/* tuple */[
                                        actualCurrent.instance.contents,
                                        Exceptions$ReView.UnboundContextInstance
                                      ], (function (prevOpaqueInstance) {
                                          var prevInstance = Opaque$ReView.$$return(prevOpaqueInstance);
                                          instance.shouldUpdate.contents = Caml_obj.caml_notequal(actualValue, prevInstance.value.contents);
                                          instance.value.contents = actualValue;
                                          return /* () */0;
                                        }));
                          }));
                  } else {
                    var instance_value = {
                      contents: actualValue
                    };
                    var instance_shouldUpdate = {
                      contents: true
                    };
                    var instance$1 = {
                      value: instance_value,
                      shouldUpdate: instance_shouldUpdate
                    };
                    wip.instance.contents = Caml_option.some(Opaque$ReView.convert(instance$1));
                  }
                  return call(current, wip, /* array */[props.children]);
                }));
  };
  var updateErrorBoundary = function (current, wip) {
    var props = Opaque$ReView.$$return(wip.props);
    return call(current, wip, props.children);
  };
  var updateFragment = function (current, wip) {
    var props = Opaque$ReView.$$return(wip.props);
    return call(current, wip, props.children);
  };
  var updateHost = function (current, wip) {
    var props = Opaque$ReView.$$return(wip.props);
    if (wip.instance.contents === undefined) {
      Let$ReView.OptionOrError.let_(/* tuple */[
            wip.constructor.contents,
            Exceptions$ReView.InvalidHostConstructor
          ], (function (constructor) {
              var stringConstructor = Opaque$ReView.$$return(constructor);
              var instance = Curry._2(Reconciler.createInstance, stringConstructor, props.attributes);
              wip.instance.contents = Caml_option.some(Opaque$ReView.convert(instance));
              return /* () */0;
            }));
    }
    return call(current, wip, props.children);
  };
  var updateMemoInitial = function (current, wip) {
    render$1(current, wip);
    var result = safelyRender(wip, (function (param) {
            return Let$ReView.OptionOrError.let_(/* tuple */[
                        wip.constructor.contents,
                        Exceptions$ReView.MissingBasicComponentConstructor
                      ], (function (constructor) {
                          var render = Opaque$ReView.$$return(constructor);
                          var props = Opaque$ReView.$$return(wip.props);
                          return Curry._2(render, {
                                      key: wip.key.contents,
                                      ref: wip.ref.contents
                                    }, props);
                        }));
          }));
    finishRender(/* () */0);
    if (result !== undefined) {
      wip.children.contents = result;
      return call(current, wip, /* array */[result]);
    }
    
  };
  var updateMemo = function (current, wip) {
    if (current !== undefined) {
      var actualCurrent = current;
      var shouldUpdate = {
        contents: actualCurrent.shouldUpdate.contents
      };
      if (!shouldUpdate.contents) {
        var deps = actualCurrent.dependencies;
        Opaque$ReView.$$Set.forEach(deps, (function (contextType) {
                var instance = read(wip, contextType);
                if (instance.shouldUpdate.contents) {
                  shouldUpdate.contents = true;
                  return /* () */0;
                } else {
                  return 0;
                }
              }));
      }
      var currentProps = Opaque$ReView.$$return(actualCurrent.props);
      var wipProps = Opaque$ReView.$$return(wip.props);
      if (shouldUpdate.contents || Caml_obj.caml_notequal(wipProps, currentProps)) {
        return updateMemoInitial(current, wip);
      } else {
        var children = actualCurrent.children.contents;
        wip.children.contents = children;
        actualCurrent.children.contents = undefined;
        return call(current, wip, /* array */[children]);
      }
    } else {
      return updateMemoInitial(current, wip);
    }
  };
  var updateMemoBasicInitial = function (current, wip) {
    var result = safelyRender(wip, (function (param) {
            return Let$ReView.OptionOrError.let_(/* tuple */[
                        wip.constructor.contents,
                        Exceptions$ReView.MissingBasicComponentConstructor
                      ], (function (constructor) {
                          var render = Opaque$ReView.$$return(constructor);
                          var props = Opaque$ReView.$$return(wip.props);
                          return Curry._2(render, {
                                      key: wip.key.contents,
                                      ref: wip.ref.contents
                                    }, props);
                        }));
          }));
    if (result !== undefined) {
      wip.children.contents = result;
      return call(current, wip, /* array */[result]);
    }
    
  };
  var updateMemoBasic = function (current, wip) {
    if (current !== undefined) {
      var actualCurrent = current;
      var currentProps = Opaque$ReView.$$return(actualCurrent.props);
      var wipProps = Opaque$ReView.$$return(wip.props);
      if (Caml_obj.caml_notequal(wipProps, currentProps)) {
        return updateMemoInitial(current, wip);
      } else {
        var children = actualCurrent.children.contents;
        wip.children.contents = children;
        actualCurrent.children.contents = undefined;
        return call(current, wip, /* array */[children]);
      }
    } else {
      return updateMemoInitial(current, wip);
    }
  };
  var updateRoot = function (current, wip) {
    var props = Opaque$ReView.$$return(wip.props);
    return call(current, wip, props.children);
  };
  var call$1 = function (current, wip) {
    var match = wip.fiberTag;
    switch (match) {
      case /* Component */0 :
          return updateComponent(current, wip);
      case /* Host */1 :
          return updateHost(current, wip);
      case /* Root */2 :
          return updateRoot(current, wip);
      case /* Fragment */3 :
          return updateFragment(current, wip);
      case /* Basic */4 :
          return updateBasic(current, wip);
      case /* Memo */5 :
          return updateMemo(current, wip);
      case /* MemoBasic */6 :
          return updateMemoBasic(current, wip);
      case /* ErrorBoundary */7 :
          return updateErrorBoundary(current, wip);
      case /* ContextProvider */8 :
          return updateContextProvider(current, wip);
      case /* ContextConsumer */9 :
          return updateContextConsumer(current, wip);
      
    }
  };
  var BeginWork = {
    safelyRender: safelyRender,
    updateBasic: updateBasic,
    updateComponent: updateComponent,
    updateContextConsumer: updateContextConsumer,
    updateContextProvider: updateContextProvider,
    updateErrorBoundary: updateErrorBoundary,
    updateFragment: updateFragment,
    updateHost: updateHost,
    updateMemoInitial: updateMemoInitial,
    updateMemo: updateMemo,
    updateMemoBasicInitial: updateMemoBasicInitial,
    updateMemoBasic: updateMemoBasic,
    updateRoot: updateRoot,
    call: call$1
  };
  var call$2 = function (wip) {
    if (wip.fiberTag === /* ErrorBoundary */7) {
      return Let$ReView.OptionUnit.let_(wip.error.contents, (function (error) {
                    var props = Opaque$ReView.$$return(wip.props);
                    return Curry._1(props.onError, error);
                  }));
    } else {
      return 0;
    }
  };
  var $$Error = {
    call: call$2
  };
  var withHost = function (wip) {
    return Let$ReView.OptionUnit.let_(getHostParent(wip), (function (parent) {
                  return Let$ReView.OptionUnit.let_(parent.instance.contents, (function (parentInstance) {
                                return Let$ReView.OptionUnit.let_(wip.instance.contents, (function (childInstance) {
                                              return Curry._3(Reconciler.appendChild, Opaque$ReView.$$return(parentInstance), Opaque$ReView.$$return(childInstance), getInstanceIndex(parent));
                                            }));
                              }));
                }));
  };
  var withHooks = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks.contents, (function (hook, param) {
                  var match = Opaque$ReView.$$return(hook);
                  if (match.tag === /* LayoutEffect */6) {
                    return Let$ReView.OptionUnit.let_(match.value.contents, (function (actualValue) {
                                  var match = Opaque$ReView.$$return(actualValue);
                                  if (match[2] === /* Placement */2) {
                                    match[1].contents = Curry._1(match[0], /* () */0);
                                    return /* () */0;
                                  } else {
                                    return 0;
                                  }
                                }));
                  } else {
                    return 0;
                  }
                }));
  };
  var call$3 = function (wip) {
    var match = wip.fiberTag;
    switch (match) {
      case /* Host */1 :
          return withHost(wip);
      case /* Component */0 :
      case /* Memo */5 :
          return withHooks(wip);
      case /* Root */2 :
      case /* Fragment */3 :
      case /* Basic */4 :
      case /* MemoBasic */6 :
      case /* ErrorBoundary */7 :
      case /* ContextProvider */8 :
      case /* ContextConsumer */9 :
          return /* () */0;
      
    }
  };
  var Placement = {
    withHost: withHost,
    withHooks: withHooks,
    call: call$3
  };
  var withHost$1 = function (wip) {
    return Let$ReView.OptionUnit.let_(getHostParent(wip), (function (parent) {
                  return Let$ReView.OptionUnit.let_(wip.instance.contents, (function (childInstance) {
                                return Let$ReView.OptionUnit.let_(wip.alternate.contents, (function (alternate) {
                                              return Curry._4(Reconciler.commitUpdate, Opaque$ReView.$$return(childInstance), Opaque$ReView.$$return(alternate.props), Opaque$ReView.$$return(wip.props), getInstanceIndex(parent));
                                            }));
                              }));
                }));
  };
  var withHooks$1 = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks.contents, (function (hook, param) {
                  var match = Opaque$ReView.$$return(hook);
                  if (match.tag === /* LayoutEffect */6) {
                    return Let$ReView.OptionUnit.let_(match.value.contents, (function (actualValue) {
                                  var match = Opaque$ReView.$$return(actualValue);
                                  if (match[2] === /* Update */3) {
                                    var cleanup = match[1];
                                    Let$ReView.OptionUnit.let_(cleanup.contents, (function (actualCleanup) {
                                            return Curry._1(actualCleanup, /* () */0);
                                          }));
                                    cleanup.contents = Curry._1(match[0], /* () */0);
                                    return /* () */0;
                                  } else {
                                    return 0;
                                  }
                                }));
                  } else {
                    return 0;
                  }
                }));
  };
  var call$4 = function (wip) {
    var match = wip.fiberTag;
    switch (match) {
      case /* Host */1 :
          return withHost$1(wip);
      case /* Component */0 :
      case /* Memo */5 :
          return withHooks$1(wip);
      case /* Root */2 :
      case /* Fragment */3 :
      case /* Basic */4 :
      case /* MemoBasic */6 :
      case /* ErrorBoundary */7 :
      case /* ContextProvider */8 :
      case /* ContextConsumer */9 :
          return /* () */0;
      
    }
  };
  var Update = {
    withHost: withHost$1,
    withHooks: withHooks$1,
    call: call$4
  };
  var withHost$2 = function (wip) {
    return Let$ReView.OptionUnit.let_(getHostParent(wip), (function (parent) {
                  return Let$ReView.OptionUnit.let_(parent.instance.contents, (function (parentInstance) {
                                return Let$ReView.OptionUnit.let_(wip.instance.contents, (function (childInstance) {
                                              return Curry._3(Reconciler.removeChild, Opaque$ReView.$$return(parentInstance), Opaque$ReView.$$return(childInstance), getInstanceIndex(parent));
                                            }));
                              }));
                }));
  };
  var withHooks$2 = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks.contents, (function (hook, param) {
                  var match = Opaque$ReView.$$return(hook);
                  if (match.tag === /* LayoutEffect */6) {
                    return Let$ReView.OptionUnit.let_(match.value.contents, (function (actualValue) {
                                  var match = Opaque$ReView.$$return(actualValue);
                                  return Let$ReView.OptionUnit.let_(match[1].contents, (function (actualCleanup) {
                                                return Curry._1(actualCleanup, /* () */0);
                                              }));
                                }));
                  } else {
                    return 0;
                  }
                }));
  };
  var commitDelete = function (wip) {
    var match = wip.fiberTag;
    switch (match) {
      case /* Host */1 :
          return withHost$2(wip);
      case /* Component */0 :
      case /* Memo */5 :
          return withHooks$2(wip);
      case /* Root */2 :
      case /* Fragment */3 :
      case /* Basic */4 :
      case /* MemoBasic */6 :
      case /* ErrorBoundary */7 :
      case /* ContextProvider */8 :
      case /* ContextConsumer */9 :
          return /* () */0;
      
    }
  };
  var commitDeleteSibling = function (wip) {
    return Let$ReView.OptionUnit.let_(wip, (function (actualFiber) {
                  commitDelete(actualFiber);
                  return commitDeleteSibling(actualFiber.sibling.contents);
                }));
  };
  var call$5 = function (wip) {
    commitDelete(wip);
    return commitDeleteSibling(wip.child.contents);
  };
  var Delete = {
    withHost: withHost$2,
    withHooks: withHooks$2,
    commitDelete: commitDelete,
    commitDeleteSibling: commitDeleteSibling,
    call: call$5
  };
  var withHooks$3 = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks.contents, (function (hook, param) {
                  var match = Opaque$ReView.$$return(hook);
                  if (match.tag === /* Effect */4) {
                    return Let$ReView.OptionUnit.let_(match.value.contents, (function (actualValue) {
                                  var match = Opaque$ReView.$$return(actualValue);
                                  if (match[2] === /* Placement */2) {
                                    match[1].contents = Curry._1(match[0], /* () */0);
                                    return /* () */0;
                                  } else {
                                    return 0;
                                  }
                                }));
                  } else {
                    return 0;
                  }
                }));
  };
  var call$6 = function (wip) {
    var match = wip.fiberTag;
    if (match !== 5 && match !== 0) {
      return /* () */0;
    } else {
      return withHooks$3(wip);
    }
  };
  var Placement$1 = {
    withHooks: withHooks$3,
    call: call$6
  };
  var withHooks$4 = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks.contents, (function (hook, param) {
                  var match = Opaque$ReView.$$return(hook);
                  if (match.tag === /* Effect */4) {
                    return Let$ReView.OptionUnit.let_(match.value.contents, (function (actualValue) {
                                  var match = Opaque$ReView.$$return(actualValue);
                                  if (match[2] === /* Update */3) {
                                    var cleanup = match[1];
                                    Let$ReView.OptionUnit.let_(cleanup.contents, (function (actualCleanup) {
                                            return Curry._1(actualCleanup, /* () */0);
                                          }));
                                    cleanup.contents = Curry._1(match[0], /* () */0);
                                    return /* () */0;
                                  } else {
                                    return 0;
                                  }
                                }));
                  } else {
                    return 0;
                  }
                }));
  };
  var call$7 = function (wip) {
    var match = wip.fiberTag;
    if (match !== 5 && match !== 0) {
      return /* () */0;
    } else {
      return withHooks$4(wip);
    }
  };
  var Update$1 = {
    withHooks: withHooks$4,
    call: call$7
  };
  var withHooks$5 = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks.contents, (function (hook, param) {
                  var match = Opaque$ReView.$$return(hook);
                  if (match.tag === /* Effect */4) {
                    return Let$ReView.OptionUnit.let_(match.value.contents, (function (actualValue) {
                                  var match = Opaque$ReView.$$return(actualValue);
                                  return Let$ReView.OptionUnit.let_(match[1].contents, (function (actualCleanup) {
                                                return Curry._1(actualCleanup, /* () */0);
                                              }));
                                }));
                  } else {
                    return 0;
                  }
                }));
  };
  var commitDelete$1 = function (wip) {
    var match = wip.fiberTag;
    if (match !== 5 && match !== 0) {
      return /* () */0;
    } else {
      return withHooks$5(wip);
    }
  };
  var commitDeleteSibling$1 = function (wip) {
    return Let$ReView.OptionUnit.let_(wip, (function (actualFiber) {
                  commitDelete$1(actualFiber);
                  return commitDeleteSibling$1(actualFiber.sibling.contents);
                }));
  };
  var call$8 = function (wip) {
    commitDelete$1(wip);
    return commitDeleteSibling$1(wip.child.contents);
  };
  var Delete$1 = {
    withHooks: withHooks$5,
    commitDelete: commitDelete$1,
    commitDeleteSibling: commitDeleteSibling$1,
    call: call$8
  };
  var safelyCommit = function (wip, commit, alternate) {
    var commitAny = function (param) {
      if (alternate !== undefined) {
        return Curry._1(commit, alternate);
      } else {
        return Curry._1(commit, wip);
      }
    };
    try {
      commitAny(/* () */0);
      return /* () */0;
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      wip.error.contents = e;
      return /* () */0;
    }
  };
  var call$9 = function (wip) {
    return Let$ReView.OptionUnit.let_(wip, (function (fiber) {
                  var commitOnChild = true;
                  var match = fiber.workTag.contents;
                  switch (match) {
                    case /* None */0 :
                    case /* Performed */1 :
                        break;
                    case /* Placement */2 :
                        safelyCommit(fiber, call$6, undefined);
                        break;
                    case /* Update */3 :
                        safelyCommit(fiber, call$7, undefined);
                        break;
                    case /* Delete */4 :
                        safelyCommit(fiber, call$8, fiber.alternate.contents);
                        commitOnChild = false;
                        break;
                    case /* Replace */5 :
                        safelyCommit(fiber, call$8, fiber.alternate.contents);
                        safelyCommit(fiber, call$6, undefined);
                        break;
                    
                  }
                  if (fiber.error.contents !== undefined) {
                    call$2(fiber);
                  } else if (commitOnChild) {
                    call$9(fiber.child.contents);
                  }
                  return call$9(fiber.sibling.contents);
                }));
  };
  var Work = {
    safelyCommit: safelyCommit,
    call: call$9
  };
  var Lifecycles = {
    Placement: Placement$1,
    Update: Update$1,
    Delete: Delete$1,
    Work: Work
  };
  var safelyCommit$1 = function (wip, commit, alternate) {
    var commitAny = function (param) {
      if (alternate !== undefined) {
        return Curry._1(commit, alternate);
      } else {
        return Curry._1(commit, wip);
      }
    };
    try {
      commitAny(/* () */0);
      return /* () */0;
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      wip.error.contents = e;
      return /* () */0;
    }
  };
  var call$10 = function (wip) {
    return Let$ReView.OptionUnit.let_(wip, (function (fiber) {
                  var commitOnChild = true;
                  var match = fiber.workTag.contents;
                  switch (match) {
                    case /* None */0 :
                    case /* Performed */1 :
                        break;
                    case /* Placement */2 :
                        safelyCommit$1(fiber, call$3, undefined);
                        break;
                    case /* Update */3 :
                        safelyCommit$1(fiber, call$4, undefined);
                        break;
                    case /* Delete */4 :
                        safelyCommit$1(fiber, call$5, fiber.alternate.contents);
                        commitOnChild = false;
                        break;
                    case /* Replace */5 :
                        safelyCommit$1(fiber, call$5, fiber.alternate.contents);
                        safelyCommit$1(fiber, call$3, undefined);
                        break;
                    
                  }
                  if (fiber.error.contents !== undefined) {
                    call$2(fiber);
                  } else if (commitOnChild) {
                    call$10(fiber.child.contents);
                  }
                  return call$10(fiber.sibling.contents);
                }));
  };
  var Work$1 = {
    safelyCommit: safelyCommit$1,
    call: call$10
  };
  var call$11 = function (param) {
    Let$ReView.OptionUnit.let_(wipRoot.contents, (function (wip) {
            return call$10(wip.child.contents);
          }));
    Let$ReView.OptionUnit.let_(currentRoot.contents, (function (current) {
            return detach(current.alternate.contents);
          }));
    currentRoot.contents = wipRoot.contents;
    wipRoot.contents = undefined;
    Let$ReView.OptionUnit.let_(currentRoot.contents, (function (current) {
            return call$10(current.child.contents);
          }));
    return /* () */0;
  };
  var Root$1 = {
    call: call$11
  };
  var Commit = {
    $$Error: $$Error,
    Placement: Placement,
    Update: Update,
    Delete: Delete,
    Lifecycles: Lifecycles,
    Work: Work$1,
    Root: Root$1
  };
  var completeUnitOfWork = function (wip) {
    return Let$ReView.$$Option.let_(wip, (function (actualWIP) {
                  var sibling = actualWIP.sibling.contents;
                  if (sibling === undefined) {
                    return completeUnitOfWork(actualWIP.parent.contents);
                  } else {
                    return sibling;
                  }
                }));
  };
  var performUnitOfWork = function (current, wip) {
    var nextWork = call$1(current, wip);
    if (nextWork === undefined) {
      return completeUnitOfWork(wip);
    } else {
      return nextWork;
    }
  };
  var workLoop = function (deadline) {
    var shouldYield = {
      contents: false
    };
    var loop = function (deadline) {
      if (shouldYield.contents) {
        return 0;
      } else {
        return Let$ReView.OptionUnit.let_(nextUnitOfWork.contents, (function (nextUnitOfWork$1) {
                      nextUnitOfWork.contents = performUnitOfWork(nextUnitOfWork$1.alternate.contents, nextUnitOfWork$1);
                      shouldYield.contents = Curry._1(deadline, /* () */0) < 1.0;
                      return loop(deadline);
                    }));
      }
    };
    loop(deadline);
    if (nextUnitOfWork.contents === undefined && wipRoot.contents !== undefined) {
      return call$11(/* () */0);
    } else {
      return 0;
    }
  };
  return {
          Fiber: Fiber,
          Context: Context,
          ErrorBoundary: ErrorBoundary,
          Fragment: Fragment,
          Root: Root,
          Host: Host,
          Core: Core,
          Utils: Utils,
          ReconcileChildren: ReconcileChildren,
          HooksContext: HooksContext,
          HooksFunction: HooksFunction,
          BeginWork: BeginWork,
          Commit: Commit,
          completeUnitOfWork: completeUnitOfWork,
          performUnitOfWork: performUnitOfWork,
          workLoop: workLoop
        };
}

exports.Engine = Engine;
/* Opaque-ReView Not a pure module */
