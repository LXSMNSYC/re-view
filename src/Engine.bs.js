// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Let$ReView = require("./Let.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Types$ReView = require("./Types.bs.js");
var Opaque$ReView = require("./Opaque.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Exceptions$ReView = require("./Exceptions.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function Make(Reconciler) {
  var index = {
    contents: 0
  };
  var make = function (name, fiberTag, props) {
    return {
            name: name,
            constructor: undefined,
            fiberTag: fiberTag,
            fiberStringTag: Curry._1(Types$ReView.Tags.Fiber.map, fiberTag),
            workTag: /* None */0,
            workStringTag: "None",
            parent: undefined,
            alternate: undefined,
            sibling: undefined,
            child: undefined,
            children: undefined,
            identifier: "",
            key: undefined,
            index: 0,
            map: Opaque$ReView.$$Map.make(undefined),
            ref: /* None */0,
            props: props,
            instance: undefined,
            hooks: Opaque$ReView.$$Array.make(undefined),
            dependencies: Opaque$ReView.$$Set.make(undefined),
            shouldUpdate: false,
            error: undefined
          };
  };
  var detach = function (detachingFiber) {
    Let$ReView.$$Option.let_(detachingFiber, (function (actualFiber) {
            var child = actualFiber.child;
            var sibling = actualFiber.sibling;
            var alternate = actualFiber.alternate;
            actualFiber.child = undefined;
            actualFiber.sibling = undefined;
            actualFiber.alternate = undefined;
            actualFiber.constructor = undefined;
            actualFiber.workTag = /* None */0;
            actualFiber.workStringTag = "None";
            actualFiber.parent = undefined;
            actualFiber.children = undefined;
            actualFiber.instance = undefined;
            detach(alternate);
            detach(child);
            detach(sibling);
            
          }));
    
  };
  var createIndex = function (param) {
    var currentIndex = index.contents + 1 | 0;
    index.contents = currentIndex;
    return currentIndex;
  };
  var Fiber = {
    index: index,
    make: make,
    detach: detach,
    createIndex: createIndex
  };
  var make$1 = function (name, defaultValue) {
    return {
            name: name,
            defaultValue: defaultValue
          };
  };
  var Instance = { };
  var make$2 = function (param, param$1) {
    var value = param$1.value;
    var context = param$1.context;
    var actualValue = value !== undefined ? Caml_option.valFromOption(value) : context.defaultValue;
    return {
            name: context.name + ".Provider",
            constructor: undefined,
            fiberTag: /* ContextProvider */8,
            key: param.key,
            ref: param.ref,
            props: {
              context: context,
              value: Caml_option.some(actualValue),
              children: param$1.children
            }
          };
  };
  var Provider = {
    make: make$2
  };
  var make$3 = function (param, param$1) {
    var context = param$1.context;
    return {
            name: context.name + ".Consumer",
            constructor: undefined,
            fiberTag: /* ContextConsumer */9,
            key: param.key,
            ref: param.ref,
            props: {
              context: context,
              build: param$1.build
            }
          };
  };
  var Consumer = {
    make: make$3
  };
  var read = function (wip, context) {
    return Let$ReView.OptionOrError.let_(/* tuple */[
                wip.parent,
                Exceptions$ReView.MissingContext
              ], (function (param) {
                  var parent = param.parent;
                  var instance = param.instance;
                  if (param.fiberTag === /* ContextProvider */8 && Caml_obj.caml_equal(param.props.context, context)) {
                    return Let$ReView.OptionOrError.let_(/* tuple */[
                                instance,
                                Exceptions$ReView.MissingContext
                              ], (function (actualInstance) {
                                  return actualInstance;
                                }));
                  } else {
                    return Let$ReView.OptionOrError.let_(/* tuple */[
                                parent,
                                Exceptions$ReView.MissingContext
                              ], (function (actualParent) {
                                  return read(actualParent, context);
                                }));
                  }
                }));
  };
  var Context = {
    make: make$1,
    Instance: Instance,
    Provider: Provider,
    Consumer: Consumer,
    read: read
  };
  var make$4 = function (param, props) {
    return {
            name: "ErrorBoundary",
            constructor: undefined,
            fiberTag: /* ErrorBoundary */7,
            key: param.key,
            ref: /* None */0,
            props: props
          };
  };
  var ErrorBoundary = {
    make: make$4
  };
  var make$5 = function (param, props) {
    return {
            name: "Fragment",
            constructor: undefined,
            fiberTag: /* Fragment */3,
            key: param.key,
            ref: /* None */0,
            props: props
          };
  };
  var Fragment = {
    make: make$5
  };
  var Root = { };
  var make$6 = function (param, param$1) {
    var constructor = param$1.constructor;
    return {
            name: constructor,
            constructor: Caml_option.some(constructor),
            fiberTag: /* Host */1,
            key: param.key,
            ref: param.ref,
            props: {
              constructor: constructor,
              attributes: param$1.attributes,
              children: param$1.children
            }
          };
  };
  var Host = {
    make: make$6
  };
  var Basic = function (C) {
    var make = function (param, props) {
      return {
              name: C.name,
              constructor: Caml_option.some(C.make),
              fiberTag: /* Basic */4,
              key: param.key,
              ref: param.ref,
              props: props
            };
    };
    return {
            name: C.name,
            make: make
          };
  };
  var MemoBasic = function (C) {
    var make = function (param, props) {
      return {
              name: C.name,
              constructor: Caml_option.some(C.make),
              fiberTag: /* MemoBasic */6,
              key: param.key,
              ref: param.ref,
              props: props
            };
    };
    return {
            name: C.name,
            make: make
          };
  };
  var Memo = function (C) {
    var make = function (param, props) {
      return {
              name: C.name,
              constructor: Caml_option.some(C.make),
              fiberTag: /* Memo */5,
              key: param.key,
              ref: param.ref,
              props: props
            };
    };
    return {
            name: C.name,
            make: make
          };
  };
  var Component = function (C) {
    var make = function (param, props) {
      return {
              name: C.name,
              constructor: Caml_option.some(C.make),
              fiberTag: /* Component */0,
              key: param.key,
              ref: param.ref,
              props: props
            };
    };
    return {
            name: C.name,
            make: make
          };
  };
  var root = {
    current: undefined,
    wip: undefined,
    next: undefined
  };
  var rootContainer = {
    contents: undefined
  };
  var updateScheduled = {
    contents: false
  };
  var renderBase = function (props) {
    var renderFiber = make("Root", /* Root */2, props);
    renderFiber.instance = rootContainer.contents;
    renderFiber.alternate = root.current;
    root.wip = renderFiber;
    root.next = renderFiber;
    
  };
  var update = function (param) {
    var current = root.current;
    var tmp;
    if (current !== undefined) {
      tmp = current.props;
    } else {
      var current$1 = root.wip;
      if (current$1 !== undefined) {
        tmp = current$1.props;
      } else {
        throw Exceptions$ReView.MissingCurrentRoot;
      }
    }
    return renderBase(tmp);
  };
  var render = function (element, container) {
    rootContainer.contents = Caml_option.some(container);
    return renderBase({
                value: container,
                children: element
              });
  };
  var Core = {
    root: root,
    rootContainer: rootContainer,
    updateScheduled: updateScheduled,
    renderBase: renderBase,
    update: update,
    render: render
  };
  var getHostParent = function (wip) {
    return Let$ReView.$$Option.let_(wip.parent, (function (parent) {
                  if (parent.fiberTag === /* Host */1 || parent.fiberTag === /* Root */2) {
                    return parent;
                  } else {
                    return getHostParent(parent);
                  }
                }));
  };
  var getInstanceIndex = function (parent, wip) {
    var count = {
      contents: 0
    };
    var found = {
      contents: false
    };
    var measure = function (currentFiber) {
      return Let$ReView.OptionUnit.let_(currentFiber, (function (current) {
                    if (!found.contents && current !== wip) {
                      if (current.fiberTag === /* Host */1) {
                        count.contents = count.contents + 1 | 0;
                      } else {
                        measure(current.child);
                      }
                      return measure(current.sibling);
                    } else {
                      found.contents = true;
                      return ;
                    }
                  }));
    };
    measure(parent.child);
    return count.contents;
  };
  var Utils = {
    getHostParent: getHostParent,
    getInstanceIndex: getInstanceIndex
  };
  var attachFiberAlternate = function (oldFiber, newFiber) {
    detach(oldFiber.alternate);
    oldFiber.alternate = undefined;
    newFiber.alternate = oldFiber;
    
  };
  var mapFiberToParent = function (parent, newFiber, index, key) {
    newFiber.parent = parent;
    newFiber.index = index;
    newFiber.key = key;
    if (key !== undefined) {
      return Opaque$ReView.$$Map.set(parent.map, key, newFiber);
    } else {
      return Opaque$ReView.$$Map.set(parent.map, index, newFiber);
    }
  };
  var replaceFiber = function (parent, oldFiber, element, index, key) {
    var replacementFiber = make(element.name, element.fiberTag, element.props);
    replacementFiber.constructor = element.constructor;
    replacementFiber.workTag = /* Replace */4;
    replacementFiber.workStringTag = "Replace";
    replacementFiber.identifier = element.name + ("-" + String(createIndex(undefined)));
    attachFiberAlternate(oldFiber, replacementFiber);
    mapFiberToParent(parent, replacementFiber, index, key);
    return replacementFiber;
  };
  var deleteFiber = function (parent, oldFiber, index, key) {
    var deletionFiber = make(oldFiber.name, oldFiber.fiberTag, oldFiber.props);
    deletionFiber.constructor = oldFiber.constructor;
    deletionFiber.workTag = /* Delete */3;
    deletionFiber.workStringTag = "Delete";
    deletionFiber.instance = oldFiber.instance;
    attachFiberAlternate(oldFiber, deletionFiber);
    mapFiberToParent(parent, deletionFiber, index, key);
    return deletionFiber;
  };
  var updateFiberFromElement = function (parent, oldFiber, element, index, key) {
    var patchFiber = make(oldFiber.name, oldFiber.fiberTag, element.props);
    patchFiber.workTag = /* Update */2;
    patchFiber.workStringTag = "Update";
    patchFiber.constructor = oldFiber.constructor;
    patchFiber.instance = oldFiber.instance;
    patchFiber.identifier = oldFiber.identifier;
    attachFiberAlternate(oldFiber, patchFiber);
    mapFiberToParent(parent, patchFiber, index, key);
    return patchFiber;
  };
  var createFiberFromElement = function (parent, element, index, key) {
    var creationFiber = make(element.name, element.fiberTag, element.props);
    creationFiber.workTag = /* Placement */1;
    creationFiber.workStringTag = "Placement";
    creationFiber.constructor = element.constructor;
    creationFiber.identifier = element.name + ("-" + String(createIndex(undefined)));
    mapFiberToParent(parent, creationFiber, index, key);
    return creationFiber;
  };
  var updateFiber = function (parent, oldFiber, element, index, key) {
    if (oldFiber !== undefined) {
      return Let$ReView.$$Option.let_(oldFiber, (function (actualOldFiber) {
                    if (actualOldFiber.workTag === /* Delete */3 && element !== undefined) {
                      return Let$ReView.$$Option.let_(element, (function (actualElement) {
                                    return createFiberFromElement(parent, actualElement, index, key);
                                  }));
                    } else if (element === undefined) {
                      return deleteFiber(parent, actualOldFiber, index, key);
                    } else {
                      return Let$ReView.$$Option.let_(element, (function (actualElement) {
                                    if (actualElement.fiberTag !== actualOldFiber.fiberTag || Caml_obj.caml_notequal(actualElement.constructor, actualOldFiber.constructor)) {
                                      return deleteFiber(parent, actualOldFiber, index, key);
                                    } else {
                                      return updateFiberFromElement(parent, actualOldFiber, actualElement, index, key);
                                    }
                                  }));
                    }
                  }));
    } else {
      return Let$ReView.$$Option.let_(element, (function (actualElement) {
                    return createFiberFromElement(parent, actualElement, index, key);
                  }));
    }
  };
  var getMatchingFiber = function (current, index, key) {
    return Let$ReView.$$Option.let_(current, (function (actualCurrent) {
                  if (key !== undefined && Opaque$ReView.$$Map.has(actualCurrent.map, key)) {
                    return Opaque$ReView.$$Map.get(actualCurrent.map, key);
                  } else {
                    return Opaque$ReView.$$Map.get(actualCurrent.map, index);
                  }
                }));
  };
  var call = function (current, wip, children) {
    var previousFiber = {
      contents: undefined
    };
    var linkFiber = function (newFiber, hasElement) {
      if (wip.child === undefined) {
        wip.child = newFiber;
      } else if (hasElement) {
        Let$ReView.OptionUnit.let_(previousFiber.contents, (function (prev) {
                prev.sibling = newFiber;
                
              }));
      }
      previousFiber.contents = newFiber;
      
    };
    var marked = Opaque$ReView.$$Set.make(undefined);
    $$Array.iteri((function (index, element) {
            var key = element !== undefined ? element.key : undefined;
            var oldFiber = getMatchingFiber(current, index, key);
            var newFiber = updateFiber(wip, oldFiber, element, index, key);
            Let$ReView.OptionUnit.let_(oldFiber, (function (actualFiber) {
                    return Opaque$ReView.$$Set.add(marked, actualFiber);
                  }));
            return linkFiber(newFiber, element !== undefined);
          }), children);
    Let$ReView.OptionUnit.let_(current, (function (actualCurrent) {
            var iterateFibers = function (oldFiber) {
              return Let$ReView.OptionUnit.let_(oldFiber, (function (iteratedFiber) {
                            if (!Opaque$ReView.$$Set.has(marked, iteratedFiber)) {
                              linkFiber(deleteFiber(wip, iteratedFiber, iteratedFiber.index, iteratedFiber.key), false);
                            }
                            return iterateFibers(iteratedFiber.sibling);
                          }));
            };
            return iterateFibers(actualCurrent.child);
          }));
    return wip.child;
  };
  var ReconcileChildren = {
    attachFiberAlternate: attachFiberAlternate,
    mapFiberToParent: mapFiberToParent,
    replaceFiber: replaceFiber,
    deleteFiber: deleteFiber,
    updateFiberFromElement: updateFiberFromElement,
    createFiberFromElement: createFiberFromElement,
    updateFiber: updateFiber,
    getMatchingFiber: getMatchingFiber,
    call: call
  };
  var Slot = { };
  var hookFiber = {
    contents: undefined
  };
  var hookCursor = {
    contents: 0
  };
  var render$1 = function (current, wip) {
    hookFiber.contents = wip;
    hookCursor.contents = 0;
    return Let$ReView.OptionUnit.let_(current, (function (actualCurrent) {
                  wip.hooks = actualCurrent.hooks;
                  actualCurrent.hooks = Opaque$ReView.$$Array.make(undefined);
                  
                }));
  };
  var finishRender = function (param) {
    hookFiber.contents = undefined;
    hookCursor.contents = 0;
    
  };
  var getCurrentFiber = function (param) {
    return Let$ReView.OptionOrError.let_(/* tuple */[
                hookFiber.contents,
                Exceptions$ReView.OutOfContextHookCall
              ], (function (currentFiber) {
                  return currentFiber;
                }));
  };
  var make$7 = function (tag) {
    var currentFiber = getCurrentFiber(undefined);
    var current = hookCursor.contents;
    var slot = Opaque$ReView.$$Array.get(currentFiber.hooks, current);
    hookCursor.contents = current + 1 | 0;
    if (slot !== undefined) {
      if (slot.tag !== tag) {
        throw Exceptions$ReView.IncompatibleHook;
      }
      return slot;
    }
    var newSlot = {
      tag: tag,
      value: undefined
    };
    Opaque$ReView.$$Array.set(currentFiber.hooks, current, newSlot);
    return newSlot;
  };
  var forEach = function (wip, handler) {
    return Opaque$ReView.$$Array.forEach(wip.hooks, (function (slot, param) {
                  return Curry._1(handler, slot);
                }));
  };
  var RenderContext = {
    hookFiber: hookFiber,
    hookCursor: hookCursor,
    render: render$1,
    finishRender: finishRender,
    getCurrentFiber: getCurrentFiber,
    make: make$7,
    forEach: forEach
  };
  var use = function (callback, dependency) {
    var state = make$7(/* Callback */0);
    var dep = make$7(/* Dependency */3);
    var actualCallback = state.value;
    if (actualCallback !== undefined && !Caml_obj.caml_notequal(dep.value, Caml_option.some(dependency))) {
      return Caml_option.valFromOption(actualCallback);
    } else {
      state.value = Caml_option.some(callback);
      dep.value = Caml_option.some(dependency);
      return callback;
    }
  };
  var Callback = {
    use: use
  };
  var use$1 = function (supplier) {
    var state = make$7(/* Constant */1);
    var value = state.value;
    if (value !== undefined) {
      return Caml_option.valFromOption(value);
    }
    var value$1 = Curry._1(supplier, undefined);
    state.value = Caml_option.some(value$1);
    return value$1;
  };
  var Constant = {
    use: use$1
  };
  var use$2 = function (context) {
    var wip = getCurrentFiber(undefined);
    var instance = read(wip, context);
    Opaque$ReView.$$Set.add(wip.dependencies, context);
    return instance.value;
  };
  var Context$1 = {
    use: use$2
  };
  var use$3 = function (effect, dependency) {
    var state = make$7(/* Effect */4);
    var dep = make$7(/* Dependency */3);
    var actualDep = dep.value;
    if (actualDep !== undefined) {
      if (Caml_obj.caml_notequal(Caml_option.valFromOption(actualDep), dependency)) {
        return Let$ReView.OptionUnit.let_(state.value, (function (opaquePrev) {
                      state.value = /* tuple */[
                        opaquePrev[0],
                        opaquePrev[1],
                        /* Update */2
                      ];
                      dep.value = Caml_option.some(dependency);
                      
                    }));
      } else {
        return ;
      }
    } else {
      state.value = /* tuple */[
        effect,
        {
          contents: undefined
        },
        /* Placement */1
      ];
      dep.value = Caml_option.some(dependency);
      return ;
    }
  };
  var Effect = {
    use: use$3
  };
  var use$4 = function (param) {
    var dispatch = make$7(/* ForceUpdate */5);
    var actualValue = dispatch.value;
    if (actualValue !== undefined) {
      return Caml_option.valFromOption(actualValue);
    }
    var callback = function (param) {
      updateScheduled.contents = true;
      
    };
    dispatch.value = Caml_option.some(callback);
    return callback;
  };
  var ForceUpdate = {
    use: use$4
  };
  var use$5 = function (effect, dependency) {
    var state = make$7(/* LayoutEffect */6);
    var dep = make$7(/* Dependency */3);
    var actualDep = dep.value;
    if (actualDep !== undefined) {
      if (Caml_obj.caml_notequal(Caml_option.valFromOption(actualDep), dependency)) {
        return Let$ReView.OptionUnit.let_(state.value, (function (opaquePrev) {
                      state.value = /* tuple */[
                        opaquePrev[0],
                        opaquePrev[1],
                        /* Update */2
                      ];
                      dep.value = Caml_option.some(dependency);
                      
                    }));
      } else {
        return ;
      }
    } else {
      state.value = /* tuple */[
        effect,
        {
          contents: undefined
        },
        /* Placement */1
      ];
      dep.value = Caml_option.some(dependency);
      return ;
    }
  };
  var LayoutEffect = {
    use: use$5
  };
  var use$6 = function (supplier, dependency) {
    var state = make$7(/* Memo */7);
    var dep = make$7(/* Dependency */3);
    var actualState = state.value;
    if (actualState !== undefined) {
      if (!Caml_obj.caml_notequal(dep.value, Caml_option.some(dependency))) {
        return Caml_option.valFromOption(actualState);
      }
      var value = Curry._1(supplier, undefined);
      state.value = Caml_option.some(value);
      dep.value = Caml_option.some(dependency);
      return value;
    }
    var value$1 = Curry._1(supplier, undefined);
    state.value = Caml_option.some(value$1);
    dep.value = Caml_option.some(dependency);
    return value$1;
  };
  var Memo$1 = {
    use: use$6
  };
  var use$7 = function (reducer, initial) {
    var wip = getCurrentFiber(undefined);
    var state = make$7(/* ReducerState */10);
    var dispatch = make$7(/* ReducerDispatch */11);
    var match = state.value;
    var match$1 = dispatch.value;
    if (match !== undefined && match$1 !== undefined) {
      return /* tuple */[
              Caml_option.valFromOption(match),
              Caml_option.valFromOption(match$1)
            ];
    }
    var initialState = Curry._1(initial, undefined);
    var callback = function (action) {
      return Let$ReView.OptionUnit.let_(state.value, (function (opaqueValue) {
                    var newState = Curry._2(reducer, opaqueValue, action);
                    if (Caml_obj.caml_notequal(newState, opaqueValue)) {
                      state.value = Caml_option.some(newState);
                      wip.shouldUpdate = true;
                      updateScheduled.contents = true;
                      return ;
                    }
                    
                  }));
    };
    state.value = Caml_option.some(initialState);
    dispatch.value = Caml_option.some(callback);
    return /* tuple */[
            initialState,
            callback
          ];
  };
  var Reducer = {
    use: use$7
  };
  var use$8 = function (initial) {
    var wip = getCurrentFiber(undefined);
    var state = make$7(/* State */8);
    var dispatch = make$7(/* SetState */9);
    var match = state.value;
    var match$1 = dispatch.value;
    if (match !== undefined && match$1 !== undefined) {
      return /* tuple */[
              Caml_option.valFromOption(match),
              Caml_option.valFromOption(match$1)
            ];
    }
    var initialState = Curry._1(initial, undefined);
    var callback = function (action) {
      return Let$ReView.OptionUnit.let_(state.value, (function (opaqueValue) {
                    var newState = Curry._1(action, opaqueValue);
                    if (Caml_obj.caml_notequal(newState, opaqueValue)) {
                      state.value = Caml_option.some(newState);
                      wip.shouldUpdate = true;
                      updateScheduled.contents = true;
                      return ;
                    }
                    
                  }));
    };
    state.value = Caml_option.some(initialState);
    dispatch.value = Caml_option.some(callback);
    return /* tuple */[
            initialState,
            callback
          ];
  };
  var State = {
    use: use$8
  };
  var use$9 = function (initialValue) {
    var state = make$7(/* Reference */13);
    var value = state.value;
    if (value !== undefined) {
      return Caml_option.valFromOption(value);
    }
    var value$1 = /* Mutable */Block.__(0, [{
          contents: Caml_option.some(initialValue)
        }]);
    state.value = Caml_option.some(value$1);
    return value$1;
  };
  var Reference = {
    use: use$9
  };
  var use$10 = function (initialValue) {
    var state = make$7(/* Mutable */12);
    var value = state.value;
    if (value !== undefined) {
      return Caml_option.valFromOption(value);
    }
    var value$1 = {
      contents: initialValue
    };
    state.value = Caml_option.some(value$1);
    return value$1;
  };
  var Mutable = {
    use: use$10
  };
  var use$11 = function (param) {
    var wip = getCurrentFiber(undefined);
    var state = make$7(/* Identifier */14);
    var value = state.value;
    if (value !== undefined) {
      return Caml_option.valFromOption(value);
    }
    var value$1 = wip.identifier;
    state.value = Caml_option.some(value$1);
    return value$1;
  };
  var Identifier = {
    use: use$11
  };
  var Functions = {
    Callback: Callback,
    Constant: Constant,
    Context: Context$1,
    Effect: Effect,
    ForceUpdate: ForceUpdate,
    LayoutEffect: LayoutEffect,
    Memo: Memo$1,
    Reducer: Reducer,
    State: State,
    Reference: Reference,
    Mutable: Mutable,
    Identifier: Identifier
  };
  var Hooks = {
    Slot: Slot,
    RenderContext: RenderContext,
    Functions: Functions
  };
  var safelyRender = function (wip, render) {
    try {
      return Curry._1(render, undefined);
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      wip.error = [
        Exceptions$ReView.Component,
        e,
        []
      ];
      return ;
    }
  };
  var updateBasic = function (current, wip) {
    var result = safelyRender(wip, (function (param) {
            return Let$ReView.OptionOrError.let_(/* tuple */[
                        wip.constructor,
                        Exceptions$ReView.MissingBasicComponentConstructor
                      ], (function (constructor) {
                          var props = wip.props;
                          return Curry._2(constructor, {
                                      key: wip.key,
                                      ref: wip.ref
                                    }, props);
                        }));
          }));
    if (result !== undefined) {
      return call(current, wip, [result]);
    }
    
  };
  var updateComponent = function (current, wip) {
    render$1(current, wip);
    var result = safelyRender(wip, (function (param) {
            return Let$ReView.OptionOrError.let_(/* tuple */[
                        wip.constructor,
                        Exceptions$ReView.MissingBasicComponentConstructor
                      ], (function (constructor) {
                          var props = wip.props;
                          return Curry._2(constructor, {
                                      key: wip.key,
                                      ref: wip.ref
                                    }, props);
                        }));
          }));
    finishRender(undefined);
    if (result !== undefined) {
      return call(current, wip, [result]);
    }
    
  };
  var updateContextConsumer = function (current, wip) {
    var props = wip.props;
    var result = safelyRender(wip, (function (param) {
            var instance = read(wip, props.context);
            var children = instance.shouldUpdate ? Curry._1(props.build, instance.value) : Let$ReView.$$Option.let_(current, (function (actualCurrent) {
                      var result = actualCurrent.children;
                      actualCurrent.children = undefined;
                      return result;
                    }));
            wip.children = children;
            return children;
          }));
    if (result !== undefined) {
      return call(current, wip, [result]);
    }
    
  };
  var updateContextProvider = function (current, wip) {
    var props = wip.props;
    return Let$ReView.OptionOrError.let_(/* tuple */[
                props.value,
                Exceptions$ReView.DesyncContextValue
              ], (function (actualValue) {
                  var actualInstance = wip.instance;
                  if (actualInstance !== undefined) {
                    var actualInstance$1 = Caml_option.valFromOption(actualInstance);
                    Let$ReView.OptionOrError.let_(/* tuple */[
                          current,
                          Exceptions$ReView.UnboundContextInstance
                        ], (function (actualCurrent) {
                            return Let$ReView.OptionOrError.let_(/* tuple */[
                                        actualCurrent.instance,
                                        Exceptions$ReView.UnboundContextInstance
                                      ], (function (prevOpaqueInstance) {
                                          actualInstance$1.shouldUpdate = Caml_obj.caml_notequal(actualValue, prevOpaqueInstance.value);
                                          actualInstance$1.value = actualValue;
                                          
                                        }));
                          }));
                  } else {
                    var instance = {
                      value: actualValue,
                      shouldUpdate: true
                    };
                    wip.instance = Caml_option.some(instance);
                  }
                  return call(current, wip, props.children);
                }));
  };
  var updateErrorBoundary = function (current, wip) {
    var props = wip.props;
    return call(current, wip, props.children);
  };
  var updateFragment = function (current, wip) {
    var props = wip.props;
    return call(current, wip, props.children);
  };
  var updateHost = function (current, wip) {
    var props = wip.props;
    if (wip.instance === undefined) {
      Let$ReView.OptionOrError.let_(/* tuple */[
            wip.constructor,
            Exceptions$ReView.InvalidHostConstructor
          ], (function (constructor) {
              var instance = Curry._4(Reconciler.createInstance, constructor, props.attributes, wip.identifier, wip);
              wip.instance = Caml_option.some(instance);
              
            }));
    }
    return call(current, wip, props.children);
  };
  var updateMemoInitial = function (current, wip) {
    render$1(current, wip);
    var result = safelyRender(wip, (function (param) {
            return Let$ReView.OptionOrError.let_(/* tuple */[
                        wip.constructor,
                        Exceptions$ReView.MissingBasicComponentConstructor
                      ], (function (constructor) {
                          var props = wip.props;
                          return Curry._2(constructor, {
                                      key: wip.key,
                                      ref: wip.ref
                                    }, props);
                        }));
          }));
    finishRender(undefined);
    if (result !== undefined) {
      wip.children = result;
      return call(current, wip, [result]);
    }
    
  };
  var updateMemo = function (current, wip) {
    if (current === undefined) {
      return updateMemoInitial(current, wip);
    }
    var shouldUpdate = {
      contents: current.shouldUpdate
    };
    if (!shouldUpdate.contents) {
      var deps = current.dependencies;
      Opaque$ReView.$$Set.forEach(deps, (function (contextType) {
              var instance = read(wip, contextType);
              if (instance.shouldUpdate) {
                shouldUpdate.contents = true;
                return ;
              }
              
            }));
    }
    var currentProps = current.props;
    var wipProps = wip.props;
    if (shouldUpdate.contents || Caml_obj.caml_notequal(wipProps, currentProps)) {
      return updateMemoInitial(current, wip);
    }
    var children = current.children;
    wip.children = children;
    current.children = undefined;
    return call(current, wip, [children]);
  };
  var updateMemoBasicInitial = function (current, wip) {
    var result = safelyRender(wip, (function (param) {
            return Let$ReView.OptionOrError.let_(/* tuple */[
                        wip.constructor,
                        Exceptions$ReView.MissingBasicComponentConstructor
                      ], (function (constructor) {
                          var props = wip.props;
                          return Curry._2(constructor, {
                                      key: wip.key,
                                      ref: wip.ref
                                    }, props);
                        }));
          }));
    if (result !== undefined) {
      wip.children = result;
      return call(current, wip, [result]);
    }
    
  };
  var updateMemoBasic = function (current, wip) {
    if (current === undefined) {
      return updateMemoInitial(current, wip);
    }
    var currentProps = current.props;
    var wipProps = wip.props;
    if (Caml_obj.caml_notequal(wipProps, currentProps)) {
      return updateMemoInitial(current, wip);
    }
    var children = current.children;
    wip.children = children;
    current.children = undefined;
    return call(current, wip, [children]);
  };
  var updateRoot = function (current, wip) {
    var props = wip.props;
    if (wip.instance === undefined) {
      wip.instance = Caml_option.some(props.value);
    }
    return call(current, wip, [props.children]);
  };
  var call$1 = function (current, wip) {
    var match = wip.fiberTag;
    switch (match) {
      case /* Component */0 :
          return updateComponent(current, wip);
      case /* Host */1 :
          return updateHost(current, wip);
      case /* Root */2 :
          return updateRoot(current, wip);
      case /* Fragment */3 :
          return updateFragment(current, wip);
      case /* Basic */4 :
          return updateBasic(current, wip);
      case /* Memo */5 :
          return updateMemo(current, wip);
      case /* MemoBasic */6 :
          return updateMemoBasic(current, wip);
      case /* ErrorBoundary */7 :
          return updateErrorBoundary(current, wip);
      case /* ContextProvider */8 :
          return updateContextProvider(current, wip);
      case /* ContextConsumer */9 :
          return updateContextConsumer(current, wip);
      
    }
  };
  var BeginWork = {
    safelyRender: safelyRender,
    updateBasic: updateBasic,
    updateComponent: updateComponent,
    updateContextConsumer: updateContextConsumer,
    updateContextProvider: updateContextProvider,
    updateErrorBoundary: updateErrorBoundary,
    updateFragment: updateFragment,
    updateHost: updateHost,
    updateMemoInitial: updateMemoInitial,
    updateMemo: updateMemo,
    updateMemoBasicInitial: updateMemoBasicInitial,
    updateMemoBasic: updateMemoBasic,
    updateRoot: updateRoot,
    call: call$1
  };
  var raiseToParent = function (wip, error) {
    return Let$ReView.OptionOrError.let_(/* tuple */[
                wip.parent,
                error
              ], (function (parent) {
                  parent.error = error;
                  
                }));
  };
  var call$2 = function (wip) {
    return Let$ReView.OptionUnit.let_(wip.error, (function (error) {
                  if (wip.fiberTag !== /* ErrorBoundary */7) {
                    if (error[0] === Exceptions$ReView.Component) {
                      return raiseToParent(wip, [
                                  Exceptions$ReView.Component,
                                  error[1],
                                  $$Array.append(error[2], [wip.identifier])
                                ]);
                    } else {
                      return raiseToParent(wip, [
                                  Exceptions$ReView.Component,
                                  error,
                                  [wip.identifier]
                                ]);
                    }
                  }
                  var props = wip.props;
                  if (error[0] === Exceptions$ReView.Component) {
                    var trace = error[2];
                    try {
                      return Curry._2(props.onError, error[1], trace);
                    }
                    catch (raw_err){
                      var err = Caml_js_exceptions.internalToOCamlException(raw_err);
                      return raiseToParent(wip, [
                                  Exceptions$ReView.Component,
                                  err,
                                  trace
                                ]);
                    }
                  } else {
                    var trace$1 = [wip.name];
                    try {
                      return Curry._2(props.onError, error, trace$1);
                    }
                    catch (raw_err$1){
                      var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
                      return raiseToParent(wip, [
                                  Exceptions$ReView.Component,
                                  err$1,
                                  trace$1
                                ]);
                    }
                  }
                }));
  };
  var $$Error = {
    raiseToParent: raiseToParent,
    call: call$2
  };
  var withHost = function (wip) {
    return Let$ReView.OptionUnit.let_(getHostParent(wip), (function (parent) {
                  return Let$ReView.OptionUnit.let_(parent.instance, (function (parentInstance) {
                                return Let$ReView.OptionUnit.let_(wip.instance, (function (childInstance) {
                                              Curry._4(Reconciler.appendChild, parentInstance, childInstance, getInstanceIndex(parent, wip), wip);
                                              var pointer = wip.ref;
                                              if (typeof pointer === "number") {
                                                return ;
                                              } else if (pointer.tag) {
                                                return Curry._1(pointer[0], childInstance);
                                              } else {
                                                pointer[0].contents = Caml_option.some(childInstance);
                                                return ;
                                              }
                                            }));
                              }));
                }));
  };
  var withHooks = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks, (function (hook, param) {
                  var value = hook.value;
                  if (hook.tag === /* LayoutEffect */6) {
                    return Let$ReView.OptionUnit.let_(value, (function (actualValue) {
                                  if (actualValue[2] === /* Placement */1) {
                                    actualValue[1].contents = Curry._1(actualValue[0], undefined);
                                    return ;
                                  }
                                  
                                }));
                  }
                  
                }));
  };
  var call$3 = function (wip) {
    var match = wip.fiberTag;
    switch (match) {
      case /* Host */1 :
          return withHost(wip);
      case /* Component */0 :
      case /* Memo */5 :
          return withHooks(wip);
      case /* Root */2 :
      case /* Fragment */3 :
      case /* Basic */4 :
      case /* MemoBasic */6 :
      case /* ErrorBoundary */7 :
      case /* ContextProvider */8 :
      case /* ContextConsumer */9 :
          return ;
      
    }
  };
  var Placement = {
    withHost: withHost,
    withHooks: withHooks,
    call: call$3
  };
  var withHost$1 = function (wip) {
    return Let$ReView.OptionUnit.let_(getHostParent(wip), (function (parent) {
                  return Let$ReView.OptionUnit.let_(wip.instance, (function (childInstance) {
                                return Let$ReView.OptionUnit.let_(wip.alternate, (function (alternate) {
                                              var returnedAltProps = alternate.props;
                                              var returnedProps = wip.props;
                                              return Curry._5(Reconciler.commitUpdate, childInstance, returnedAltProps.attributes, returnedProps.attributes, getInstanceIndex(parent, wip), wip);
                                            }));
                              }));
                }));
  };
  var withHooks$1 = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks, (function (hook, param) {
                  var value = hook.value;
                  if (hook.tag === /* LayoutEffect */6) {
                    return Let$ReView.OptionUnit.let_(value, (function (actualValue) {
                                  if (actualValue[2] !== /* Update */2) {
                                    return ;
                                  }
                                  var cleanup = actualValue[1];
                                  Let$ReView.OptionUnit.let_(cleanup.contents, (function (actualCleanup) {
                                          return Curry._1(actualCleanup, undefined);
                                        }));
                                  cleanup.contents = Curry._1(actualValue[0], undefined);
                                  
                                }));
                  }
                  
                }));
  };
  var call$4 = function (wip) {
    var match = wip.fiberTag;
    switch (match) {
      case /* Host */1 :
          return withHost$1(wip);
      case /* Component */0 :
      case /* Memo */5 :
          return withHooks$1(wip);
      case /* Root */2 :
      case /* Fragment */3 :
      case /* Basic */4 :
      case /* MemoBasic */6 :
      case /* ErrorBoundary */7 :
      case /* ContextProvider */8 :
      case /* ContextConsumer */9 :
          return ;
      
    }
  };
  var Update = {
    withHost: withHost$1,
    withHooks: withHooks$1,
    call: call$4
  };
  var withHost$2 = function (wip) {
    return Let$ReView.OptionUnit.let_(getHostParent(wip), (function (parent) {
                  return Let$ReView.OptionUnit.let_(parent.instance, (function (parentInstance) {
                                return Let$ReView.OptionUnit.let_(wip.instance, (function (childInstance) {
                                              Curry._4(Reconciler.removeChild, parentInstance, childInstance, getInstanceIndex(parent, wip), wip);
                                              var pointer = wip.ref;
                                              if (typeof pointer === "number" || pointer.tag) {
                                                return ;
                                              } else {
                                                pointer[0].contents = undefined;
                                                return ;
                                              }
                                            }));
                              }));
                }));
  };
  var withHooks$2 = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks, (function (hook, param) {
                  var value = hook.value;
                  if (hook.tag === /* LayoutEffect */6) {
                    return Let$ReView.OptionUnit.let_(value, (function (actualValue) {
                                  return Let$ReView.OptionUnit.let_(actualValue[1].contents, (function (actualCleanup) {
                                                return Curry._1(actualCleanup, undefined);
                                              }));
                                }));
                  }
                  
                }));
  };
  var commitDelete = function (wip) {
    var match = wip.fiberTag;
    switch (match) {
      case /* Host */1 :
          return withHost$2(wip);
      case /* Component */0 :
      case /* Memo */5 :
          return withHooks$2(wip);
      case /* Root */2 :
      case /* Fragment */3 :
      case /* Basic */4 :
      case /* MemoBasic */6 :
      case /* ErrorBoundary */7 :
      case /* ContextProvider */8 :
      case /* ContextConsumer */9 :
          return ;
      
    }
  };
  var commitDeleteSibling = function (wip) {
    return Let$ReView.OptionUnit.let_(wip, (function (actualFiber) {
                  commitDelete(actualFiber);
                  return commitDeleteSibling(actualFiber.sibling);
                }));
  };
  var call$5 = function (wip) {
    commitDelete(wip);
    return commitDeleteSibling(wip.child);
  };
  var Delete = {
    withHost: withHost$2,
    withHooks: withHooks$2,
    commitDelete: commitDelete,
    commitDeleteSibling: commitDeleteSibling,
    call: call$5
  };
  var withHooks$3 = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks, (function (hook, param) {
                  var value = hook.value;
                  if (hook.tag === /* Effect */4) {
                    return Let$ReView.OptionUnit.let_(value, (function (actualValue) {
                                  if (actualValue[2] === /* Placement */1) {
                                    actualValue[1].contents = Curry._1(actualValue[0], undefined);
                                    return ;
                                  }
                                  
                                }));
                  }
                  
                }));
  };
  var call$6 = function (wip) {
    var match = wip.fiberTag;
    if (match !== 5 && match !== 0) {
      return ;
    } else {
      return withHooks$3(wip);
    }
  };
  var Placement$1 = {
    withHooks: withHooks$3,
    call: call$6
  };
  var withHooks$4 = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks, (function (hook, param) {
                  var value = hook.value;
                  if (hook.tag === /* Effect */4) {
                    return Let$ReView.OptionUnit.let_(value, (function (actualValue) {
                                  if (actualValue[2] !== /* Update */2) {
                                    return ;
                                  }
                                  var cleanup = actualValue[1];
                                  Let$ReView.OptionUnit.let_(cleanup.contents, (function (actualCleanup) {
                                          return Curry._1(actualCleanup, undefined);
                                        }));
                                  cleanup.contents = Curry._1(actualValue[0], undefined);
                                  
                                }));
                  }
                  
                }));
  };
  var call$7 = function (wip) {
    var match = wip.fiberTag;
    if (match !== 5 && match !== 0) {
      return ;
    } else {
      return withHooks$4(wip);
    }
  };
  var Update$1 = {
    withHooks: withHooks$4,
    call: call$7
  };
  var withHooks$5 = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks, (function (hook, param) {
                  var value = hook.value;
                  if (hook.tag === /* Effect */4) {
                    return Let$ReView.OptionUnit.let_(value, (function (actualValue) {
                                  return Let$ReView.OptionUnit.let_(actualValue[1].contents, (function (actualCleanup) {
                                                return Curry._1(actualCleanup, undefined);
                                              }));
                                }));
                  }
                  
                }));
  };
  var commitDelete$1 = function (wip) {
    var match = wip.fiberTag;
    if (match !== 5 && match !== 0) {
      return ;
    } else {
      return withHooks$5(wip);
    }
  };
  var commitDeleteSibling$1 = function (wip) {
    return Let$ReView.OptionUnit.let_(wip, (function (actualFiber) {
                  commitDelete$1(actualFiber);
                  return commitDeleteSibling$1(actualFiber.sibling);
                }));
  };
  var call$8 = function (wip) {
    commitDelete$1(wip);
    return commitDeleteSibling$1(wip.child);
  };
  var Delete$1 = {
    withHooks: withHooks$5,
    commitDelete: commitDelete$1,
    commitDeleteSibling: commitDeleteSibling$1,
    call: call$8
  };
  var commitWork = function (wip, commit, alternate) {
    if (alternate !== undefined) {
      return Curry._1(commit, alternate);
    } else {
      return Curry._1(commit, wip);
    }
  };
  var call$9 = function (wip) {
    return Let$ReView.OptionUnit.let_(wip, (function (commitingFiber) {
                  var commitOnChild = {
                    contents: true
                  };
                  var commitSelf = function (param) {
                    var match = commitingFiber.workTag;
                    switch (match) {
                      case /* None */0 :
                          return ;
                      case /* Placement */1 :
                          return commitWork(commitingFiber, call$6, undefined);
                      case /* Update */2 :
                          return commitWork(commitingFiber, call$7, undefined);
                      case /* Delete */3 :
                          commitWork(commitingFiber, call$8, commitingFiber.alternate);
                          commitOnChild.contents = false;
                          return ;
                      case /* Replace */4 :
                          commitWork(commitingFiber, call$8, commitingFiber.alternate);
                          return commitWork(commitingFiber, call$6, undefined);
                      
                    }
                  };
                  commitSelf(undefined);
                  if (commitingFiber.error !== undefined) {
                    call$2(commitingFiber);
                  } else if (commitOnChild.contents) {
                    call$9(commitingFiber.child);
                    if (commitingFiber.error !== undefined) {
                      call$2(commitingFiber);
                    }
                    
                  }
                  return call$9(commitingFiber.sibling);
                }));
  };
  var Work = {
    commitWork: commitWork,
    call: call$9
  };
  var Lifecycles = {
    Placement: Placement$1,
    Update: Update$1,
    Delete: Delete$1,
    Work: Work
  };
  var commitWork$1 = function (wip, commit, alternate) {
    if (alternate !== undefined) {
      return Curry._1(commit, alternate);
    } else {
      return Curry._1(commit, wip);
    }
  };
  var call$10 = function (wip) {
    return Let$ReView.OptionUnit.let_(wip, (function (commitingFiber) {
                  var commitOnChild = {
                    contents: true
                  };
                  var commitSelf = function (param) {
                    var match = commitingFiber.workTag;
                    switch (match) {
                      case /* None */0 :
                          return ;
                      case /* Placement */1 :
                          return commitWork$1(commitingFiber, call$3, undefined);
                      case /* Update */2 :
                          return commitWork$1(commitingFiber, call$4, undefined);
                      case /* Delete */3 :
                          commitWork$1(commitingFiber, call$5, commitingFiber.alternate);
                          commitOnChild.contents = false;
                          return ;
                      case /* Replace */4 :
                          commitWork$1(commitingFiber, call$5, commitingFiber.alternate);
                          return commitWork$1(commitingFiber, call$3, undefined);
                      
                    }
                  };
                  commitSelf(undefined);
                  if (commitingFiber.error !== undefined) {
                    call$2(commitingFiber);
                  } else if (commitOnChild.contents) {
                    call$10(commitingFiber.child);
                    if (commitingFiber.error !== undefined) {
                      call$2(commitingFiber);
                    }
                    
                  }
                  return call$10(commitingFiber.sibling);
                }));
  };
  var Work$1 = {
    commitWork: commitWork$1,
    call: call$10
  };
  var call$11 = function (param) {
    updateScheduled.contents = false;
    return Let$ReView.OptionOrError.let_(/* tuple */[
                root.wip,
                Exceptions$ReView.MissingWorkInProgressRoot
              ], (function (wip) {
                  call$10(wip.child);
                  Let$ReView.OptionUnit.let_(root.current, (function (current) {
                          return detach(current.alternate);
                        }));
                  root.current = root.wip;
                  root.wip = undefined;
                  call$9(wip.child);
                  if (updateScheduled.contents) {
                    update(undefined);
                    updateScheduled.contents = false;
                    return ;
                  }
                  
                }));
  };
  var Root$1 = {
    call: call$11
  };
  var Commit = {
    $$Error: $$Error,
    Placement: Placement,
    Update: Update,
    Delete: Delete,
    Lifecycles: Lifecycles,
    Work: Work$1,
    Root: Root$1
  };
  var completeUnitOfWork = function (wip) {
    return Let$ReView.$$Option.let_(wip, (function (actualWIP) {
                  var sibling = actualWIP.sibling;
                  if (sibling === undefined) {
                    return completeUnitOfWork(actualWIP.parent);
                  } else {
                    return sibling;
                  }
                }));
  };
  var performUnitOfWork = function (current, wip) {
    var nextWork = call$1(current, wip);
    if (nextWork === undefined) {
      return completeUnitOfWork(wip);
    } else {
      return nextWork;
    }
  };
  var Test = Caml_exceptions.create("Engine-ReView.Make(Reconciler).Test");
  var workLoop = function (deadline) {
    var shouldYield = {
      contents: false
    };
    var loop = function (deadline) {
      if (!shouldYield.contents) {
        return Let$ReView.OptionUnit.let_(root.next, (function (nextUnitOfWork) {
                      root.next = performUnitOfWork(nextUnitOfWork.alternate, nextUnitOfWork);
                      shouldYield.contents = Curry._1(deadline, undefined) < 1.0;
                      return loop(deadline);
                    }));
      }
      
    };
    loop(deadline);
    if (root.next === undefined && root.wip !== undefined) {
      return call$11(undefined);
    }
    
  };
  return {
          Fiber: Fiber,
          Context: Context,
          ErrorBoundary: ErrorBoundary,
          Fragment: Fragment,
          Root: Root,
          Host: Host,
          Basic: Basic,
          MemoBasic: MemoBasic,
          Memo: Memo,
          Component: Component,
          Core: Core,
          Utils: Utils,
          ReconcileChildren: ReconcileChildren,
          Hooks: Hooks,
          BeginWork: BeginWork,
          Commit: Commit,
          completeUnitOfWork: completeUnitOfWork,
          performUnitOfWork: performUnitOfWork,
          Test: Test,
          workLoop: workLoop,
          useCallback: use,
          useConstant: use$1,
          useContext: use$2,
          useEffect: use$3,
          useForceUpdate: use$4,
          useIdentifier: use$11,
          useLayoutEffect: use$5,
          useMemo: use$6,
          useMutable: use$10,
          useReducer: use$7,
          useReference: use$9,
          useState: use$8
        };
}

exports.Make = Make;
/* Opaque-ReView Not a pure module */
