// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Let$ReView = require("./Let.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Opaque$ReView = require("./Opaque.bs.js");
var Exceptions$ReView = require("./Exceptions.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function Make(Reconciler) {
  var index = {
    contents: 0
  };
  var make = function (fiberTag, props) {
    return {
            constructor: undefined,
            fiberTag: fiberTag,
            workTag: /* None */0,
            parent: undefined,
            alternate: undefined,
            sibling: undefined,
            child: undefined,
            children: undefined,
            identifier: 0,
            key: undefined,
            index: 0,
            indeces: 0,
            map: Opaque$ReView.$$Map.make(/* () */0),
            ref: /* None */0,
            props: props,
            instance: undefined,
            error: undefined,
            hooks: Opaque$ReView.$$Array.make(/* () */0),
            dependencies: Opaque$ReView.$$Set.make(/* () */0),
            shouldUpdate: false
          };
  };
  var detach = function (fiber) {
    Let$ReView.$$Option.let_(fiber, (function (actualFiber) {
            var child = actualFiber.child;
            var sibling = actualFiber.sibling;
            var alternate = actualFiber.alternate;
            actualFiber.child = undefined;
            actualFiber.sibling = undefined;
            actualFiber.alternate = undefined;
            detach(alternate);
            detach(child);
            detach(sibling);
            return ;
          }));
    return /* () */0;
  };
  var createIndex = function (param) {
    var currentIndex = index.contents + 1 | 0;
    index.contents = currentIndex;
    return currentIndex;
  };
  var Fiber = {
    index: index,
    make: make,
    detach: detach,
    createIndex: createIndex
  };
  var Instance = { };
  var make$1 = function (param, param$1) {
    var value = param$1.value;
    var context = param$1.context;
    var actualValue = value !== undefined ? Caml_option.valFromOption(value) : context.defaultValue;
    return {
            constructor: undefined,
            fiberTag: /* ContextProvider */8,
            key: param.key,
            ref: param.ref,
            props: {
              context: context,
              value: Caml_option.some(actualValue),
              children: param$1.children
            }
          };
  };
  var Provider = {
    make: make$1
  };
  var make$2 = function (param, param$1) {
    return {
            constructor: undefined,
            fiberTag: /* ContextConsumer */9,
            key: param.key,
            ref: param.ref,
            props: {
              context: param$1.context,
              build: param$1.build
            }
          };
  };
  var Consumer = {
    make: make$2
  };
  var read = function (wip, context) {
    return Let$ReView.OptionOrError.let_(/* tuple */[
                wip.parent,
                Exceptions$ReView.MissingContext
              ], (function (param) {
                  var parent = param.parent;
                  var instance = param.instance;
                  if (param.fiberTag === /* ContextProvider */8 && Caml_obj.caml_equal(param.props.context, context)) {
                    return Let$ReView.OptionOrError.let_(/* tuple */[
                                instance,
                                Exceptions$ReView.MissingContext
                              ], (function (actualInstance) {
                                  return actualInstance;
                                }));
                  } else {
                    return Let$ReView.OptionOrError.let_(/* tuple */[
                                parent,
                                Exceptions$ReView.MissingContext
                              ], (function (actualParent) {
                                  return read(actualParent, context);
                                }));
                  }
                }));
  };
  var Context = {
    Instance: Instance,
    Provider: Provider,
    Consumer: Consumer,
    read: read
  };
  var make$3 = function (param, props) {
    return {
            constructor: undefined,
            fiberTag: /* ErrorBoundary */7,
            key: param.key,
            ref: /* None */0,
            props: props
          };
  };
  var ErrorBoundary = {
    make: make$3
  };
  var make$4 = function (param, props) {
    return {
            constructor: undefined,
            fiberTag: /* Fragment */3,
            key: param.key,
            ref: /* None */0,
            props: props
          };
  };
  var Fragment = {
    make: make$4
  };
  var Root = { };
  var make$5 = function (param, param$1) {
    var constructor = param$1.constructor;
    return {
            constructor: Caml_option.some(constructor),
            fiberTag: /* Host */1,
            key: param.key,
            ref: param.ref,
            props: {
              constructor: constructor,
              attributes: param$1.attributes,
              children: param$1.children
            }
          };
  };
  var Host = {
    make: make$5
  };
  var Basic = function (C) {
    var make = function (param, props) {
      return {
              constructor: Caml_option.some(C.make),
              fiberTag: /* Basic */4,
              key: param.key,
              ref: param.ref,
              props: props
            };
    };
    return {
            make: make
          };
  };
  var MemoBasic = function (C) {
    var make = function (param, props) {
      return {
              constructor: Caml_option.some(C.make),
              fiberTag: /* MemoBasic */6,
              key: param.key,
              ref: param.ref,
              props: props
            };
    };
    return {
            make: make
          };
  };
  var Memo = function (C) {
    var make = function (param, props) {
      return {
              constructor: Caml_option.some(C.make),
              fiberTag: /* Memo */5,
              key: param.key,
              ref: param.ref,
              props: props
            };
    };
    return {
            make: make
          };
  };
  var Component = function (C) {
    var make = function (param, props) {
      return {
              constructor: Caml_option.some(C.make),
              fiberTag: /* Component */0,
              key: param.key,
              ref: param.ref,
              props: props
            };
    };
    return {
            make: make
          };
  };
  var currentRoot = {
    contents: undefined
  };
  var wipRoot = {
    contents: undefined
  };
  var nextUnitOfWork = {
    contents: undefined
  };
  var update = function (param) {
    return Let$ReView.OptionUnit.let_(currentRoot.contents, (function (current) {
                  var fiber = make(/* Root */2, current.props);
                  fiber.instance = current.instance;
                  fiber.alternate = current.alternate;
                  wipRoot.contents = fiber;
                  nextUnitOfWork.contents = fiber;
                  return /* () */0;
                }));
  };
  var render = function (element, container) {
    var props_children = element;
    var props = {
      value: container,
      children: props_children
    };
    var fiber = make(/* Root */2, props);
    fiber.instance = Caml_option.some(container);
    fiber.alternate = currentRoot.contents;
    wipRoot.contents = fiber;
    nextUnitOfWork.contents = fiber;
    return /* () */0;
  };
  var Core = {
    currentRoot: currentRoot,
    wipRoot: wipRoot,
    nextUnitOfWork: nextUnitOfWork,
    update: update,
    render: render
  };
  var getHostParent = function (wip) {
    return Let$ReView.$$Option.let_(wip.parent, (function (parent) {
                  if (parent.fiberTag === /* Host */1 || parent.fiberTag === /* Root */2) {
                    return parent;
                  } else {
                    return getHostParent(parent);
                  }
                }));
  };
  var getInstanceIndex = function (wip) {
    var index = wip.indeces;
    wip.indeces = index + 1 | 0;
    return index;
  };
  var Utils = {
    getHostParent: getHostParent,
    getInstanceIndex: getInstanceIndex
  };
  var attachFiberAlternate = function (oldFiber, newFiber) {
    detach(oldFiber.alternate);
    oldFiber.alternate = undefined;
    newFiber.alternate = oldFiber;
    return /* () */0;
  };
  var mapFiberToParent = function (parent, newFiber, index, key) {
    newFiber.parent = parent;
    newFiber.index = index;
    newFiber.key = key;
    if (key !== undefined) {
      return Opaque$ReView.$$Map.set(parent.map, key, newFiber);
    } else {
      return Opaque$ReView.$$Map.set(parent.map, index, newFiber);
    }
  };
  var replaceFiber = function (parent, oldFiber, element, index, key) {
    var fiber = make(element.fiberTag, element.props);
    fiber.constructor = element.constructor;
    fiber.workTag = /* Replace */4;
    fiber.identifier = createIndex(/* () */0);
    attachFiberAlternate(oldFiber, fiber);
    mapFiberToParent(parent, fiber, index, key);
    return fiber;
  };
  var deleteFiber = function (parent, oldFiber, index, key) {
    var fiber = make(oldFiber.fiberTag, oldFiber.props);
    fiber.constructor = oldFiber.constructor;
    fiber.workTag = /* Delete */3;
    fiber.instance = oldFiber.instance;
    attachFiberAlternate(oldFiber, fiber);
    mapFiberToParent(parent, fiber, index, key);
    return fiber;
  };
  var updateFiberFromElement = function (parent, oldFiber, element, index, key) {
    var fiber = make(oldFiber.fiberTag, element.props);
    fiber.workTag = /* Update */2;
    fiber.constructor = oldFiber.constructor;
    fiber.instance = oldFiber.instance;
    fiber.identifier = oldFiber.identifier;
    attachFiberAlternate(oldFiber, fiber);
    mapFiberToParent(parent, fiber, index, key);
    return fiber;
  };
  var createFiberFromElement = function (parent, element, index, key) {
    var fiber = make(element.fiberTag, element.props);
    fiber.workTag = /* Placement */1;
    fiber.constructor = element.constructor;
    fiber.identifier = createIndex(/* () */0);
    mapFiberToParent(parent, fiber, index, key);
    return fiber;
  };
  var updateFiber = function (parent, oldFiber, element, index, key) {
    if (oldFiber !== undefined) {
      var actualOldFiber = oldFiber;
      if (element !== undefined) {
        var actualElement = element;
        return actualOldFiber.workTag === /* Delete */3 ? createFiberFromElement(parent, actualElement, index, key) : (
                  actualElement.fiberTag !== actualOldFiber.fiberTag || Caml_obj.caml_notequal(actualElement.constructor, actualOldFiber.constructor) ? replaceFiber(parent, actualOldFiber, actualElement, index, key) : updateFiberFromElement(parent, actualOldFiber, actualElement, index, key)
                );
      } else {
        return deleteFiber(parent, actualOldFiber, index, key);
      }
    } else if (element !== undefined) {
      return createFiberFromElement(parent, element, index, key);
    } else {
      return ;
    }
  };
  var getMatchingFiber = function (current, index, key) {
    return Let$ReView.$$Option.let_(current, (function (actualCurrent) {
                  if (key !== undefined) {
                    var actualKey = key;
                    if (Opaque$ReView.$$Map.has(actualCurrent.map, actualKey)) {
                      return Opaque$ReView.$$Map.get(actualCurrent.map, actualKey);
                    } else {
                      return Opaque$ReView.$$Map.get(actualCurrent.map, index);
                    }
                  } else {
                    return Opaque$ReView.$$Map.get(actualCurrent.map, index);
                  }
                }));
  };
  var call = function (current, wip, newChildren) {
    var previousFiber = {
      contents: undefined
    };
    var linkFiber = function (newFiber, hasElement) {
      return Let$ReView.OptionUnit.let_(newFiber, (function (fiber) {
                    if (wip.child === undefined) {
                      wip.child = fiber;
                    } else if (hasElement) {
                      Let$ReView.OptionUnit.let_(previousFiber.contents, (function (prev) {
                              prev.sibling = fiber;
                              return /* () */0;
                            }));
                    }
                    previousFiber.contents = fiber;
                    return /* () */0;
                  }));
    };
    var marked = Opaque$ReView.$$Set.make(/* () */0);
    Let$ReView.OptionUnit.let_(newChildren, (function (children) {
            return $$Array.iteri((function (index, element) {
                          var key = element !== undefined ? element.key : undefined;
                          var oldFiber = getMatchingFiber(current, index, key);
                          var newFiber = updateFiber(wip, oldFiber, element, index, key);
                          Let$ReView.OptionUnit.let_(oldFiber, (function (actualFiber) {
                                  return Opaque$ReView.$$Set.add(marked, actualFiber);
                                }));
                          return linkFiber(newFiber, element !== undefined);
                        }), children);
          }));
    Let$ReView.OptionUnit.let_(current, (function (actualCurrent) {
            var iterateFibers = function (oldFiber) {
              return Let$ReView.OptionUnit.let_(oldFiber, (function (fiber) {
                            if (!Opaque$ReView.$$Set.has(marked, fiber)) {
                              linkFiber(deleteFiber(wip, fiber, fiber.index, fiber.key), false);
                            }
                            return iterateFibers(fiber.sibling);
                          }));
            };
            return iterateFibers(actualCurrent.child);
          }));
    return wip.child;
  };
  var ReconcileChildren = {
    attachFiberAlternate: attachFiberAlternate,
    mapFiberToParent: mapFiberToParent,
    replaceFiber: replaceFiber,
    deleteFiber: deleteFiber,
    updateFiberFromElement: updateFiberFromElement,
    createFiberFromElement: createFiberFromElement,
    updateFiber: updateFiber,
    getMatchingFiber: getMatchingFiber,
    call: call
  };
  var Slot = { };
  var hookFiber = {
    contents: undefined
  };
  var hookCursor = {
    contents: 0
  };
  var render$1 = function (current, wip) {
    hookFiber.contents = wip;
    hookCursor.contents = 0;
    return Let$ReView.OptionUnit.let_(current, (function (actualCurrent) {
                  wip.hooks = actualCurrent.hooks;
                  actualCurrent.hooks = Opaque$ReView.$$Array.make(/* () */0);
                  return /* () */0;
                }));
  };
  var finishRender = function (param) {
    hookFiber.contents = undefined;
    hookCursor.contents = 0;
    return /* () */0;
  };
  var getCurrentFiber = function (param) {
    return Let$ReView.OptionOrError.let_(/* tuple */[
                hookFiber.contents,
                Exceptions$ReView.OutOfContextHookCall
              ], (function (fiber) {
                  return fiber;
                }));
  };
  var make$6 = function (tag) {
    var fiber = getCurrentFiber(/* () */0);
    var slot = Opaque$ReView.$$Array.get(fiber.hooks, hookCursor.contents);
    hookCursor.contents = hookCursor.contents + 1 | 0;
    if (slot !== undefined) {
      var actualSlot = slot;
      if (actualSlot.tag !== tag) {
        throw Exceptions$ReView.IncompatibleHook;
      }
      return actualSlot;
    } else {
      var newSlot_value = {
        contents: undefined
      };
      var newSlot = {
        tag: tag,
        value: newSlot_value
      };
      Opaque$ReView.$$Array.set(fiber.hooks, hookCursor.contents, newSlot);
      return newSlot;
    }
  };
  var forEach = function (wip, handler) {
    return Opaque$ReView.$$Array.forEach(wip.hooks, (function (slot, param) {
                  return Curry._1(handler, slot);
                }));
  };
  var RenderContext = {
    hookFiber: hookFiber,
    hookCursor: hookCursor,
    render: render$1,
    finishRender: finishRender,
    getCurrentFiber: getCurrentFiber,
    make: make$6,
    forEach: forEach
  };
  var use = function (callback, dependency) {
    var state = make$6(/* Callback */0);
    var dep = make$6(/* Dependency */3);
    var match = state.value.contents;
    if (match !== undefined && !Caml_obj.caml_notequal(dep.value.contents, Caml_option.some(dependency))) {
      return Caml_option.valFromOption(match);
    } else {
      state.value.contents = Caml_option.some(callback);
      dep.value.contents = Caml_option.some(dependency);
      return callback;
    }
  };
  var Callback = {
    use: use
  };
  var use$1 = function (supplier) {
    var state = make$6(/* Constant */1);
    var match = state.value.contents;
    if (match !== undefined) {
      return Caml_option.valFromOption(match);
    } else {
      var value = Curry._1(supplier, /* () */0);
      state.value.contents = Caml_option.some(value);
      return value;
    }
  };
  var Constant = {
    use: use$1
  };
  var use$2 = function (context) {
    var wip = getCurrentFiber(/* () */0);
    var instance = read(wip, context);
    Opaque$ReView.$$Set.add(wip.dependencies, context);
    return instance.value.contents;
  };
  var Context$1 = {
    use: use$2
  };
  var use$3 = function (effect, dependency) {
    var state = make$6(/* Effect */4);
    var dep = make$6(/* Dependency */3);
    var match = dep.value.contents;
    if (match !== undefined) {
      if (Caml_obj.caml_notequal(Caml_option.valFromOption(match), dependency)) {
        return Let$ReView.OptionUnit.let_(state.value.contents, (function (opaquePrev) {
                      state.value.contents = /* tuple */[
                        opaquePrev[0],
                        opaquePrev[1],
                        /* Update */2
                      ];
                      dep.value.contents = Caml_option.some(dependency);
                      return /* () */0;
                    }));
      } else {
        return 0;
      }
    } else {
      state.value.contents = /* tuple */[
        effect,
        {
          contents: undefined
        },
        /* Placement */1
      ];
      dep.value.contents = Caml_option.some(dependency);
      return /* () */0;
    }
  };
  var Effect = {
    use: use$3
  };
  var use$4 = function (param) {
    var dispatch = make$6(/* ForceUpdate */5);
    var match = dispatch.value.contents;
    if (match !== undefined) {
      return Caml_option.valFromOption(match);
    } else {
      var callback = function (param) {
        return update(/* () */0);
      };
      dispatch.value.contents = Caml_option.some(callback);
      return callback;
    }
  };
  var ForceUpdate = {
    use: use$4
  };
  var use$5 = function (effect, dependency) {
    var state = make$6(/* LayoutEffect */6);
    var dep = make$6(/* Dependency */3);
    var match = dep.value.contents;
    if (match !== undefined) {
      if (Caml_obj.caml_notequal(Caml_option.valFromOption(match), dependency)) {
        return Let$ReView.OptionUnit.let_(state.value.contents, (function (opaquePrev) {
                      state.value.contents = /* tuple */[
                        opaquePrev[0],
                        opaquePrev[1],
                        /* Update */2
                      ];
                      dep.value.contents = Caml_option.some(dependency);
                      return /* () */0;
                    }));
      } else {
        return 0;
      }
    } else {
      state.value.contents = /* tuple */[
        effect,
        {
          contents: undefined
        },
        /* Placement */1
      ];
      dep.value.contents = Caml_option.some(dependency);
      return /* () */0;
    }
  };
  var LayoutEffect = {
    use: use$5
  };
  var use$6 = function (supplier, dependency) {
    var state = make$6(/* Memo */7);
    var dep = make$6(/* Dependency */3);
    var match = state.value.contents;
    if (match !== undefined) {
      if (Caml_obj.caml_notequal(dep.value.contents, Caml_option.some(dependency))) {
        var value = Curry._1(supplier, /* () */0);
        state.value.contents = Caml_option.some(value);
        dep.value.contents = Caml_option.some(dependency);
        return value;
      } else {
        return Caml_option.valFromOption(match);
      }
    } else {
      var value$1 = Curry._1(supplier, /* () */0);
      state.value.contents = Caml_option.some(value$1);
      dep.value.contents = Caml_option.some(dependency);
      return value$1;
    }
  };
  var Memo$1 = {
    use: use$6
  };
  var use$7 = function (reducer, initial) {
    var wip = getCurrentFiber(/* () */0);
    var state = make$6(/* ReducerState */10);
    var dispatch = make$6(/* ReducerDispatch */11);
    var match = state.value.contents;
    var match$1 = dispatch.value.contents;
    if (match !== undefined && match$1 !== undefined) {
      return /* tuple */[
              Caml_option.valFromOption(match),
              Caml_option.valFromOption(match$1)
            ];
    }
    var initialState = Curry._1(initial, /* () */0);
    var callback = function (action) {
      return Let$ReView.OptionUnit.let_(state.value.contents, (function (opaqueValue) {
                    var newState = Curry._2(reducer, opaqueValue, action);
                    if (Caml_obj.caml_notequal(newState, opaqueValue)) {
                      state.value.contents = Caml_option.some(newState);
                      wip.shouldUpdate = true;
                      return update(/* () */0);
                    } else {
                      return 0;
                    }
                  }));
    };
    state.value.contents = Caml_option.some(initialState);
    dispatch.value.contents = Caml_option.some(callback);
    return /* tuple */[
            initialState,
            callback
          ];
  };
  var Reducer = {
    use: use$7
  };
  var use$8 = function (initial) {
    var wip = getCurrentFiber(/* () */0);
    var state = make$6(/* State */8);
    var dispatch = make$6(/* SetState */9);
    var match = state.value.contents;
    var match$1 = dispatch.value.contents;
    if (match !== undefined && match$1 !== undefined) {
      return /* tuple */[
              Caml_option.valFromOption(match),
              Caml_option.valFromOption(match$1)
            ];
    }
    var initialState = Curry._1(initial, /* () */0);
    var callback = function (action) {
      return Let$ReView.OptionUnit.let_(state.value.contents, (function (opaqueValue) {
                    var newState = Curry._1(action, /* () */0);
                    if (newState !== opaqueValue) {
                      state.value.contents = Caml_option.some(newState);
                      wip.shouldUpdate = true;
                      return update(/* () */0);
                    } else {
                      return 0;
                    }
                  }));
    };
    state.value.contents = Caml_option.some(initialState);
    dispatch.value.contents = Caml_option.some(callback);
    return /* tuple */[
            initialState,
            callback
          ];
  };
  var State = {
    use: use$8
  };
  var use$9 = function (initialValue) {
    var state = make$6(/* Reference */13);
    var match = state.value.contents;
    if (match !== undefined) {
      return Caml_option.valFromOption(match);
    } else {
      var value = /* Mutable */Block.__(0, [{
            contents: Caml_option.some(initialValue)
          }]);
      state.value.contents = Caml_option.some(value);
      return value;
    }
  };
  var Reference = {
    use: use$9
  };
  var use$10 = function (initialValue) {
    var state = make$6(/* Mutable */12);
    var match = state.value.contents;
    if (match !== undefined) {
      return Caml_option.valFromOption(match);
    } else {
      var value = {
        contents: initialValue
      };
      state.value.contents = Caml_option.some(value);
      return value;
    }
  };
  var Mutable = {
    use: use$10
  };
  var use$11 = function (param) {
    var wip = getCurrentFiber(/* () */0);
    var state = make$6(/* Identifier */14);
    var match = state.value.contents;
    if (match !== undefined) {
      return Caml_option.valFromOption(match);
    } else {
      var value = wip.identifier;
      state.value.contents = Caml_option.some(value);
      return value;
    }
  };
  var Identifier = {
    use: use$11
  };
  var Functions = {
    Callback: Callback,
    Constant: Constant,
    Context: Context$1,
    Effect: Effect,
    ForceUpdate: ForceUpdate,
    LayoutEffect: LayoutEffect,
    Memo: Memo$1,
    Reducer: Reducer,
    State: State,
    Reference: Reference,
    Mutable: Mutable,
    Identifier: Identifier
  };
  var Hooks = {
    Slot: Slot,
    RenderContext: RenderContext,
    Functions: Functions
  };
  var safelyRender = function (wip, render) {
    try {
      return Curry._1(render, /* () */0);
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      wip.error = e;
      return ;
    }
  };
  var updateBasic = function (current, wip) {
    var result = safelyRender(wip, (function (param) {
            return Let$ReView.OptionOrError.let_(/* tuple */[
                        wip.constructor,
                        Exceptions$ReView.MissingBasicComponentConstructor
                      ], (function (constructor) {
                          var props = wip.props;
                          return Curry._2(constructor, {
                                      key: wip.key,
                                      ref: wip.ref
                                    }, props);
                        }));
          }));
    if (result !== undefined) {
      return call(current, wip, /* array */[result]);
    }
    
  };
  var updateComponent = function (current, wip) {
    render$1(current, wip);
    var result = safelyRender(wip, (function (param) {
            return Let$ReView.OptionOrError.let_(/* tuple */[
                        wip.constructor,
                        Exceptions$ReView.MissingBasicComponentConstructor
                      ], (function (constructor) {
                          var props = wip.props;
                          return Curry._2(constructor, props, {
                                      key: wip.key,
                                      ref: wip.ref
                                    });
                        }));
          }));
    finishRender(/* () */0);
    if (result !== undefined) {
      return call(current, wip, /* array */[result]);
    }
    
  };
  var updateContextConsumer = function (current, wip) {
    var props = wip.props;
    var result = safelyRender(wip, (function (param) {
            var instance = read(wip, props.context);
            var children = instance.shouldUpdate.contents ? Curry._1(props.build, instance.value.contents) : Let$ReView.$$Option.let_(current, (function (actualCurrent) {
                      var result = actualCurrent.children;
                      actualCurrent.children = undefined;
                      return result;
                    }));
            wip.children = children;
            return children;
          }));
    if (result !== undefined) {
      return call(current, wip, /* array */[result]);
    }
    
  };
  var updateContextProvider = function (current, wip) {
    var props = wip.props;
    return Let$ReView.OptionOrError.let_(/* tuple */[
                props.value,
                Exceptions$ReView.DesyncContextValue
              ], (function (actualValue) {
                  var match = wip.instance;
                  if (match !== undefined) {
                    var actualInstance = Caml_option.valFromOption(match);
                    Let$ReView.OptionOrError.let_(/* tuple */[
                          current,
                          Exceptions$ReView.UnboundContextInstance
                        ], (function (actualCurrent) {
                            return Let$ReView.OptionOrError.let_(/* tuple */[
                                        actualCurrent.instance,
                                        Exceptions$ReView.UnboundContextInstance
                                      ], (function (prevOpaqueInstance) {
                                          actualInstance.shouldUpdate.contents = Caml_obj.caml_notequal(actualValue, prevOpaqueInstance.value.contents);
                                          actualInstance.value.contents = actualValue;
                                          return /* () */0;
                                        }));
                          }));
                  } else {
                    var instance_value = {
                      contents: actualValue
                    };
                    var instance_shouldUpdate = {
                      contents: true
                    };
                    var instance = {
                      value: instance_value,
                      shouldUpdate: instance_shouldUpdate
                    };
                    wip.instance = Caml_option.some(instance);
                  }
                  return call(current, wip, /* array */[props.children]);
                }));
  };
  var updateErrorBoundary = function (current, wip) {
    var props = wip.props;
    return call(current, wip, props.children);
  };
  var updateFragment = function (current, wip) {
    var props = wip.props;
    return call(current, wip, props.children);
  };
  var updateHost = function (current, wip) {
    var props = wip.props;
    if (wip.instance === undefined) {
      Let$ReView.OptionOrError.let_(/* tuple */[
            wip.constructor,
            Exceptions$ReView.InvalidHostConstructor
          ], (function (constructor) {
              var instance = Curry._2(Reconciler.createInstance, constructor, props.attributes);
              wip.instance = Caml_option.some(instance);
              return /* () */0;
            }));
    }
    return call(current, wip, props.children);
  };
  var updateMemoInitial = function (current, wip) {
    render$1(current, wip);
    var result = safelyRender(wip, (function (param) {
            return Let$ReView.OptionOrError.let_(/* tuple */[
                        wip.constructor,
                        Exceptions$ReView.MissingBasicComponentConstructor
                      ], (function (constructor) {
                          var props = wip.props;
                          return Curry._2(constructor, {
                                      key: wip.key,
                                      ref: wip.ref
                                    }, props);
                        }));
          }));
    finishRender(/* () */0);
    if (result !== undefined) {
      wip.children = result;
      return call(current, wip, /* array */[result]);
    }
    
  };
  var updateMemo = function (current, wip) {
    if (current !== undefined) {
      var actualCurrent = current;
      var shouldUpdate = {
        contents: actualCurrent.shouldUpdate
      };
      if (!shouldUpdate.contents) {
        var deps = actualCurrent.dependencies;
        Opaque$ReView.$$Set.forEach(deps, (function (contextType) {
                var instance = read(wip, contextType);
                if (instance.shouldUpdate.contents) {
                  shouldUpdate.contents = true;
                  return /* () */0;
                } else {
                  return 0;
                }
              }));
      }
      var currentProps = actualCurrent.props;
      var wipProps = wip.props;
      if (shouldUpdate.contents || Caml_obj.caml_notequal(wipProps, currentProps)) {
        return updateMemoInitial(current, wip);
      } else {
        var children = actualCurrent.children;
        wip.children = children;
        actualCurrent.children = undefined;
        return call(current, wip, /* array */[children]);
      }
    } else {
      return updateMemoInitial(current, wip);
    }
  };
  var updateMemoBasicInitial = function (current, wip) {
    var result = safelyRender(wip, (function (param) {
            return Let$ReView.OptionOrError.let_(/* tuple */[
                        wip.constructor,
                        Exceptions$ReView.MissingBasicComponentConstructor
                      ], (function (constructor) {
                          var props = wip.props;
                          return Curry._2(constructor, {
                                      key: wip.key,
                                      ref: wip.ref
                                    }, props);
                        }));
          }));
    if (result !== undefined) {
      wip.children = result;
      return call(current, wip, /* array */[result]);
    }
    
  };
  var updateMemoBasic = function (current, wip) {
    if (current !== undefined) {
      var actualCurrent = current;
      var currentProps = actualCurrent.props;
      var wipProps = wip.props;
      if (Caml_obj.caml_notequal(wipProps, currentProps)) {
        return updateMemoInitial(current, wip);
      } else {
        var children = actualCurrent.children;
        wip.children = children;
        actualCurrent.children = undefined;
        return call(current, wip, /* array */[children]);
      }
    } else {
      return updateMemoInitial(current, wip);
    }
  };
  var updateRoot = function (current, wip) {
    var props = wip.props;
    if (wip.instance === undefined) {
      wip.instance = Caml_option.some(props.value);
    }
    return call(current, wip, /* array */[props.children]);
  };
  var call$1 = function (current, wip) {
    var match = wip.fiberTag;
    switch (match) {
      case /* Component */0 :
          return updateComponent(current, wip);
      case /* Host */1 :
          return updateHost(current, wip);
      case /* Root */2 :
          return updateRoot(current, wip);
      case /* Fragment */3 :
          return updateFragment(current, wip);
      case /* Basic */4 :
          return updateBasic(current, wip);
      case /* Memo */5 :
          return updateMemo(current, wip);
      case /* MemoBasic */6 :
          return updateMemoBasic(current, wip);
      case /* ErrorBoundary */7 :
          return updateErrorBoundary(current, wip);
      case /* ContextProvider */8 :
          return updateContextProvider(current, wip);
      case /* ContextConsumer */9 :
          return updateContextConsumer(current, wip);
      
    }
  };
  var BeginWork = {
    safelyRender: safelyRender,
    updateBasic: updateBasic,
    updateComponent: updateComponent,
    updateContextConsumer: updateContextConsumer,
    updateContextProvider: updateContextProvider,
    updateErrorBoundary: updateErrorBoundary,
    updateFragment: updateFragment,
    updateHost: updateHost,
    updateMemoInitial: updateMemoInitial,
    updateMemo: updateMemo,
    updateMemoBasicInitial: updateMemoBasicInitial,
    updateMemoBasic: updateMemoBasic,
    updateRoot: updateRoot,
    call: call$1
  };
  var call$2 = function (wip) {
    if (wip.fiberTag === /* ErrorBoundary */7) {
      return Let$ReView.OptionUnit.let_(wip.error, (function (error) {
                    var props = wip.props;
                    return Curry._1(props.onError, error);
                  }));
    } else {
      return 0;
    }
  };
  var $$Error = {
    call: call$2
  };
  var withHost = function (wip) {
    return Let$ReView.OptionUnit.let_(getHostParent(wip), (function (parent) {
                  return Let$ReView.OptionUnit.let_(parent.instance, (function (parentInstance) {
                                return Let$ReView.OptionUnit.let_(wip.instance, (function (childInstance) {
                                              Curry._3(Reconciler.appendChild, parentInstance, childInstance, getInstanceIndex(parent));
                                              var match = wip.ref;
                                              if (typeof match === "number") {
                                                return /* () */0;
                                              } else if (match.tag) {
                                                return Curry._1(match[0], childInstance);
                                              } else {
                                                match[0].contents = Caml_option.some(childInstance);
                                                return /* () */0;
                                              }
                                            }));
                              }));
                }));
  };
  var withHooks = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks, (function (hook, param) {
                  if (hook.tag === /* LayoutEffect */6) {
                    return Let$ReView.OptionUnit.let_(hook.value.contents, (function (actualValue) {
                                  if (actualValue[2] === /* Placement */1) {
                                    actualValue[1].contents = Curry._1(actualValue[0], /* () */0);
                                    return /* () */0;
                                  } else {
                                    return 0;
                                  }
                                }));
                  } else {
                    return 0;
                  }
                }));
  };
  var call$3 = function (wip) {
    var match = wip.fiberTag;
    switch (match) {
      case /* Host */1 :
          return withHost(wip);
      case /* Component */0 :
      case /* Memo */5 :
          return withHooks(wip);
      case /* Root */2 :
      case /* Fragment */3 :
      case /* Basic */4 :
      case /* MemoBasic */6 :
      case /* ErrorBoundary */7 :
      case /* ContextProvider */8 :
      case /* ContextConsumer */9 :
          return /* () */0;
      
    }
  };
  var Placement = {
    withHost: withHost,
    withHooks: withHooks,
    call: call$3
  };
  var withHost$1 = function (wip) {
    return Let$ReView.OptionUnit.let_(getHostParent(wip), (function (parent) {
                  return Let$ReView.OptionUnit.let_(wip.instance, (function (childInstance) {
                                return Let$ReView.OptionUnit.let_(wip.alternate, (function (alternate) {
                                              return Curry._4(Reconciler.commitUpdate, childInstance, alternate.props, wip.props, getInstanceIndex(parent));
                                            }));
                              }));
                }));
  };
  var withHooks$1 = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks, (function (hook, param) {
                  if (hook.tag === /* LayoutEffect */6) {
                    return Let$ReView.OptionUnit.let_(hook.value.contents, (function (actualValue) {
                                  if (actualValue[2] === /* Update */2) {
                                    var cleanup = actualValue[1];
                                    Let$ReView.OptionUnit.let_(cleanup.contents, (function (actualCleanup) {
                                            return Curry._1(actualCleanup, /* () */0);
                                          }));
                                    cleanup.contents = Curry._1(actualValue[0], /* () */0);
                                    return /* () */0;
                                  } else {
                                    return 0;
                                  }
                                }));
                  } else {
                    return 0;
                  }
                }));
  };
  var call$4 = function (wip) {
    var match = wip.fiberTag;
    switch (match) {
      case /* Host */1 :
          return withHost$1(wip);
      case /* Component */0 :
      case /* Memo */5 :
          return withHooks$1(wip);
      case /* Root */2 :
      case /* Fragment */3 :
      case /* Basic */4 :
      case /* MemoBasic */6 :
      case /* ErrorBoundary */7 :
      case /* ContextProvider */8 :
      case /* ContextConsumer */9 :
          return /* () */0;
      
    }
  };
  var Update = {
    withHost: withHost$1,
    withHooks: withHooks$1,
    call: call$4
  };
  var withHost$2 = function (wip) {
    return Let$ReView.OptionUnit.let_(getHostParent(wip), (function (parent) {
                  return Let$ReView.OptionUnit.let_(parent.instance, (function (parentInstance) {
                                return Let$ReView.OptionUnit.let_(wip.instance, (function (childInstance) {
                                              Curry._3(Reconciler.removeChild, parentInstance, childInstance, getInstanceIndex(parent));
                                              var match = wip.ref;
                                              if (typeof match === "number" || match.tag) {
                                                return /* () */0;
                                              } else {
                                                match[0].contents = undefined;
                                                return /* () */0;
                                              }
                                            }));
                              }));
                }));
  };
  var withHooks$2 = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks, (function (hook, param) {
                  if (hook.tag === /* LayoutEffect */6) {
                    return Let$ReView.OptionUnit.let_(hook.value.contents, (function (actualValue) {
                                  return Let$ReView.OptionUnit.let_(actualValue[1].contents, (function (actualCleanup) {
                                                return Curry._1(actualCleanup, /* () */0);
                                              }));
                                }));
                  } else {
                    return 0;
                  }
                }));
  };
  var commitDelete = function (wip) {
    var match = wip.fiberTag;
    switch (match) {
      case /* Host */1 :
          return withHost$2(wip);
      case /* Component */0 :
      case /* Memo */5 :
          return withHooks$2(wip);
      case /* Root */2 :
      case /* Fragment */3 :
      case /* Basic */4 :
      case /* MemoBasic */6 :
      case /* ErrorBoundary */7 :
      case /* ContextProvider */8 :
      case /* ContextConsumer */9 :
          return /* () */0;
      
    }
  };
  var commitDeleteSibling = function (wip) {
    return Let$ReView.OptionUnit.let_(wip, (function (actualFiber) {
                  commitDelete(actualFiber);
                  return commitDeleteSibling(actualFiber.sibling);
                }));
  };
  var call$5 = function (wip) {
    commitDelete(wip);
    return commitDeleteSibling(wip.child);
  };
  var Delete = {
    withHost: withHost$2,
    withHooks: withHooks$2,
    commitDelete: commitDelete,
    commitDeleteSibling: commitDeleteSibling,
    call: call$5
  };
  var withHooks$3 = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks, (function (hook, param) {
                  if (hook.tag === /* Effect */4) {
                    return Let$ReView.OptionUnit.let_(hook.value.contents, (function (actualValue) {
                                  if (actualValue[2] === /* Placement */1) {
                                    actualValue[1].contents = Curry._1(actualValue[0], /* () */0);
                                    return /* () */0;
                                  } else {
                                    return 0;
                                  }
                                }));
                  } else {
                    return 0;
                  }
                }));
  };
  var call$6 = function (wip) {
    var match = wip.fiberTag;
    if (match !== 5 && match !== 0) {
      return /* () */0;
    } else {
      return withHooks$3(wip);
    }
  };
  var Placement$1 = {
    withHooks: withHooks$3,
    call: call$6
  };
  var withHooks$4 = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks, (function (hook, param) {
                  if (hook.tag === /* Effect */4) {
                    return Let$ReView.OptionUnit.let_(hook.value.contents, (function (actualValue) {
                                  if (actualValue[2] === /* Update */2) {
                                    var cleanup = actualValue[1];
                                    Let$ReView.OptionUnit.let_(cleanup.contents, (function (actualCleanup) {
                                            return Curry._1(actualCleanup, /* () */0);
                                          }));
                                    cleanup.contents = Curry._1(actualValue[0], /* () */0);
                                    return /* () */0;
                                  } else {
                                    return 0;
                                  }
                                }));
                  } else {
                    return 0;
                  }
                }));
  };
  var call$7 = function (wip) {
    var match = wip.fiberTag;
    if (match !== 5 && match !== 0) {
      return /* () */0;
    } else {
      return withHooks$4(wip);
    }
  };
  var Update$1 = {
    withHooks: withHooks$4,
    call: call$7
  };
  var withHooks$5 = function (wip) {
    return Opaque$ReView.$$Array.forEach(wip.hooks, (function (hook, param) {
                  if (hook.tag === /* Effect */4) {
                    return Let$ReView.OptionUnit.let_(hook.value.contents, (function (actualValue) {
                                  return Let$ReView.OptionUnit.let_(actualValue[1].contents, (function (actualCleanup) {
                                                return Curry._1(actualCleanup, /* () */0);
                                              }));
                                }));
                  } else {
                    return 0;
                  }
                }));
  };
  var commitDelete$1 = function (wip) {
    var match = wip.fiberTag;
    if (match !== 5 && match !== 0) {
      return /* () */0;
    } else {
      return withHooks$5(wip);
    }
  };
  var commitDeleteSibling$1 = function (wip) {
    return Let$ReView.OptionUnit.let_(wip, (function (actualFiber) {
                  commitDelete$1(actualFiber);
                  return commitDeleteSibling$1(actualFiber.sibling);
                }));
  };
  var call$8 = function (wip) {
    commitDelete$1(wip);
    return commitDeleteSibling$1(wip.child);
  };
  var Delete$1 = {
    withHooks: withHooks$5,
    commitDelete: commitDelete$1,
    commitDeleteSibling: commitDeleteSibling$1,
    call: call$8
  };
  var safelyCommit = function (wip, commit, alternate) {
    var commitAny = function (param) {
      if (alternate !== undefined) {
        return Curry._1(commit, alternate);
      } else {
        return Curry._1(commit, wip);
      }
    };
    try {
      commitAny(/* () */0);
      return /* () */0;
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      wip.error = e;
      return /* () */0;
    }
  };
  var call$9 = function (wip) {
    return Let$ReView.OptionUnit.let_(wip, (function (fiber) {
                  var commitOnChild = true;
                  var match = fiber.workTag;
                  switch (match) {
                    case /* None */0 :
                        break;
                    case /* Placement */1 :
                        safelyCommit(fiber, call$6, undefined);
                        break;
                    case /* Update */2 :
                        safelyCommit(fiber, call$7, undefined);
                        break;
                    case /* Delete */3 :
                        safelyCommit(fiber, call$8, fiber.alternate);
                        commitOnChild = false;
                        break;
                    case /* Replace */4 :
                        safelyCommit(fiber, call$8, fiber.alternate);
                        safelyCommit(fiber, call$6, undefined);
                        break;
                    
                  }
                  if (fiber.error !== undefined) {
                    call$2(fiber);
                  } else if (commitOnChild) {
                    call$9(fiber.child);
                  }
                  return call$9(fiber.sibling);
                }));
  };
  var Work = {
    safelyCommit: safelyCommit,
    call: call$9
  };
  var Lifecycles = {
    Placement: Placement$1,
    Update: Update$1,
    Delete: Delete$1,
    Work: Work
  };
  var safelyCommit$1 = function (wip, commit, alternate) {
    var commitAny = function (param) {
      if (alternate !== undefined) {
        return Curry._1(commit, alternate);
      } else {
        return Curry._1(commit, wip);
      }
    };
    try {
      commitAny(/* () */0);
      return /* () */0;
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      wip.error = e;
      return /* () */0;
    }
  };
  var call$10 = function (wip) {
    return Let$ReView.OptionUnit.let_(wip, (function (fiber) {
                  var commitOnChild = true;
                  var match = fiber.workTag;
                  switch (match) {
                    case /* None */0 :
                        break;
                    case /* Placement */1 :
                        safelyCommit$1(fiber, call$3, undefined);
                        break;
                    case /* Update */2 :
                        safelyCommit$1(fiber, call$4, undefined);
                        break;
                    case /* Delete */3 :
                        safelyCommit$1(fiber, call$5, fiber.alternate);
                        commitOnChild = false;
                        break;
                    case /* Replace */4 :
                        safelyCommit$1(fiber, call$5, fiber.alternate);
                        safelyCommit$1(fiber, call$3, undefined);
                        break;
                    
                  }
                  if (fiber.error !== undefined) {
                    call$2(fiber);
                  } else if (commitOnChild) {
                    call$10(fiber.child);
                  }
                  return call$10(fiber.sibling);
                }));
  };
  var Work$1 = {
    safelyCommit: safelyCommit$1,
    call: call$10
  };
  var call$11 = function (param) {
    Let$ReView.OptionUnit.let_(wipRoot.contents, (function (wip) {
            return call$10(wip.child);
          }));
    Let$ReView.OptionUnit.let_(currentRoot.contents, (function (current) {
            return detach(current.alternate);
          }));
    currentRoot.contents = wipRoot.contents;
    wipRoot.contents = undefined;
    Let$ReView.OptionUnit.let_(currentRoot.contents, (function (current) {
            return call$10(current.child);
          }));
    return /* () */0;
  };
  var Root$1 = {
    call: call$11
  };
  var Commit = {
    $$Error: $$Error,
    Placement: Placement,
    Update: Update,
    Delete: Delete,
    Lifecycles: Lifecycles,
    Work: Work$1,
    Root: Root$1
  };
  var completeUnitOfWork = function (wip) {
    return Let$ReView.$$Option.let_(wip, (function (actualWIP) {
                  var sibling = actualWIP.sibling;
                  if (sibling === undefined) {
                    return completeUnitOfWork(actualWIP.parent);
                  } else {
                    return sibling;
                  }
                }));
  };
  var performUnitOfWork = function (current, wip) {
    var nextWork = call$1(current, wip);
    if (nextWork === undefined) {
      return completeUnitOfWork(wip);
    } else {
      return nextWork;
    }
  };
  var workLoop = function (deadline) {
    var shouldYield = {
      contents: false
    };
    var loop = function (deadline) {
      if (shouldYield.contents) {
        return 0;
      } else {
        return Let$ReView.OptionUnit.let_(nextUnitOfWork.contents, (function (nextUnitOfWork$1) {
                      nextUnitOfWork.contents = performUnitOfWork(nextUnitOfWork$1.alternate, nextUnitOfWork$1);
                      shouldYield.contents = Curry._1(deadline, /* () */0) < 1.0;
                      return loop(deadline);
                    }));
      }
    };
    loop(deadline);
    if (nextUnitOfWork.contents === undefined && wipRoot.contents !== undefined) {
      return call$11(/* () */0);
    } else {
      return 0;
    }
  };
  return {
          Fiber: Fiber,
          Context: Context,
          ErrorBoundary: ErrorBoundary,
          Fragment: Fragment,
          Root: Root,
          Host: Host,
          Basic: Basic,
          MemoBasic: MemoBasic,
          Memo: Memo,
          Component: Component,
          Core: Core,
          Utils: Utils,
          ReconcileChildren: ReconcileChildren,
          Hooks: Hooks,
          BeginWork: BeginWork,
          Commit: Commit,
          completeUnitOfWork: completeUnitOfWork,
          performUnitOfWork: performUnitOfWork,
          workLoop: workLoop,
          useCallback: use,
          useConstant: use$1,
          useContext: use$2,
          useEffect: use$3,
          useForceUpdate: use$4,
          useIdentifier: use$11,
          useLayoutEffect: use$5,
          useMemo: use$6,
          useMutable: use$10,
          useReducer: use$7,
          useReference: use$9,
          useState: use$8
        };
}

exports.Make = Make;
/* Opaque-ReView Not a pure module */
